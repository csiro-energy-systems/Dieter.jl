<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model formulation · Dieter.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Dieter.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><a class="tocitem" href="../../quick_start_guide/">Quick Start Guide</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Model formulation</a><ul class="internal"><li><a class="tocitem" href="#The-optimization-model"><span>The optimization model</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/public/">Public API Reference</a></li><li><a class="tocitem" href="../../api/internal/">Internal API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Model formulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model formulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/csiro-energy-systems/Dieter.jl/blob/main/docs/src/tutorials/optmodel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Model-formulation"><a class="docs-heading-anchor" href="#Model-formulation">Model formulation</a><a id="Model-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-formulation" title="Permalink"></a></h1><ul><li><a href="#Model-formulation">Model formulation</a></li><li class="no-marker"><ul><li><a href="#The-optimization-model">The optimization model</a></li><li class="no-marker"><ul><li><a href="#Index-sets">Index sets</a></li><li class="no-marker"><ul><li><a href="#Temporal">Temporal</a></li><li><a href="#Spatial">Spatial</a></li><li><a href="#Transmission">Transmission</a></li><li><a href="#Technological">Technological</a></li><li><a href="#Mapping-between-index-sets">Mapping between index sets</a></li></ul></li><li><a href="#Variables">Variables</a></li><li class="no-marker"><ul><li><a href="#Generation-operational-variables">Generation operational variables</a></li><li><a href="#Storage-operational-variables">Storage operational variables</a></li></ul></li><li><a href="#Generation-and-storage-capacity-variables">Generation and storage capacity variables</a></li><li class="no-marker"><ul><li><a href="#Transmission-network-variables">Transmission network variables</a></li><li><a href="#Hydrogen-production-operational-variables">Hydrogen production operational variables</a></li><li><a href="#Hydrogen-capacity-variables">Hydrogen capacity variables</a></li></ul></li><li><a href="#Objective-function">Objective function</a></li><li class="no-marker"><ul><li><a href="#Operational-costs">Operational costs</a></li><li><a href="#Capacity-investment-costs">Capacity investment costs</a></li></ul></li><li><a href="#Constraints">Constraints</a></li><li class="no-marker"><ul><li><a href="#Energy-balance-and-load">Energy balance and load</a></li><li><a href="#Operational-conditions-and-constraints">Operational conditions and constraints</a></li><li><a href="#Requirements-for-renewable-generation">Requirements for renewable generation</a></li><li><a href="#Storage-technologies">Storage technologies</a></li><li><a href="#Hydrogen-technologies">Hydrogen technologies</a></li></ul></li></ul></li></ul></li></ul><h2 id="The-optimization-model"><a class="docs-heading-anchor" href="#The-optimization-model">The optimization model</a><a id="The-optimization-model-1"></a><a class="docs-heading-anchor-permalink" href="#The-optimization-model" title="Permalink"></a></h2><p>The Dieter.jl package contains Julia functions to generate <a href="https://github.com/jump-dev/JuMP.jl">JuMP</a> linear programming model instances. Each model has a system cost-minimising objective, with  energy and power variables representing technology capacities and operational states. </p><p>While there are degrees of flexibility around the final problem formulation, there are some core structures that remain invariant across models.</p><h3 id="Index-sets"><a class="docs-heading-anchor" href="#Index-sets">Index sets</a><a id="Index-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Index-sets" title="Permalink"></a></h3><p>Each optimization model is structured around some key indexing sets related to</p><ul><li>Temporal</li><li>Spatial</li><li>Transmission</li><li>Technological</li></ul><h4 id="Temporal"><a class="docs-heading-anchor" href="#Temporal">Temporal</a><a id="Temporal-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal" title="Permalink"></a></h4><p>The time indexing of DIETER is typically over 8760 hours of a single full year. The set of time-steps is written <span>$\text{Hours}$</span> or <code>Hours</code>. The start and end day of the year itself is not assumed.</p><p>For example, in the code we have something akin to</p><pre><code class="language-julia hljs">hoursInYear = 8760
Timestep = 1
Hours = 1:Timestep:hoursInYear
# [1, 2, ..., 8759, 8760]</code></pre><h4 id="Spatial"><a class="docs-heading-anchor" href="#Spatial">Spatial</a><a id="Spatial-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial" title="Permalink"></a></h4><p>The model is represented spatially as a network graph, where generation and demand activity is located at nodes (or vertices), while connections between nodes are represented as directed edges (or lines). A typical node in the model represents a region of a system in which we aggregate the operations and capacities of technologies. We may assign to a node a demand requirement, for electricity or another commodity, that must be satisfied by energy production.</p><p>For example, we might define a set of nodes as a simple array of string labels:</p><pre><code class="language-julia hljs">Nodes = [&quot;R1&quot;, &quot;R2&quot;, &quot;R3&quot;]</code></pre><p>We use both the terms &quot;region&quot; and &quot;zone&quot; to refer to spatial entities, often using &quot;region&quot; to refer to the largest spatial grouping in the model, and a &quot;zone&quot; to mean a sub-region. Specific examples are transmission zones (abbreviated <code>TxZones</code>) and renewable energy zones (abbreviated <code>REZones</code>, used for aggregating variable renewable energy resources).</p><h4 id="Transmission"><a class="docs-heading-anchor" href="#Transmission">Transmission</a><a id="Transmission-1"></a><a class="docs-heading-anchor-permalink" href="#Transmission" title="Permalink"></a></h4><p>Transmission lines transfer electrical power from supply to demand. As mentioned, regions or zones are connected by lines, represented as ordered pairs of spatial nodes. We refer to these lines as <code>Arcs</code> in the models: an arc may represent what in reality is a transmission link comprised of one or more physical transmission lines.</p><p>A basic line representation is a pair consisting of two spatial regions. We collect all lines in the set <code>Arcs</code></p><p>For example:</p><pre><code class="language-julia hljs">Arcs = [(&quot;R1&quot;,&quot;R2&quot;), (&quot;R2&quot;, &quot;R1&quot;), (&quot;R2,R3&quot;), (&quot;R2&quot;, &quot;R3&quot;)]</code></pre><p>Here the network topology is a linear graph (R1 ⇆ R2 ⇆ R3) where both directions of a connection between regions are explicitly included in the set.</p><h4 id="Technological"><a class="docs-heading-anchor" href="#Technological">Technological</a><a id="Technological-1"></a><a class="docs-heading-anchor-permalink" href="#Technological" title="Permalink"></a></h4><p>Technologies are sub-categorised as follows:</p><ul><li>Conventional (fossil fuel-based) electrical generators</li><li>Variable renewable electrical generators</li><li>Energy storage devices</li><li>Hydrogen production devices</li></ul><p>The set <code>Techs</code> contains variable and dispatchable electricity generation types, for example</p><pre><code class="language-julia hljs">Techs = [&quot;Wind&quot;, &quot;SolarPV&quot;, &quot;Hydro&quot;, &quot;CCGT&quot;, &quot;OCGT&quot;]</code></pre><p>and is distinguished from the set <code>Storages</code> of energy storage technology types, for example</p><pre><code class="language-julia hljs">Storages = [&quot;LIonBattery&quot;, &quot;PumpedHydro&quot;, &quot;CAES&quot;, &quot;RedoxBattery&quot;]</code></pre><p>since the model constraints differ for these two categories.</p><p>In the case of hydrogen technology, the set <code>P2G</code> contains hydrogen electrolysers, and <code>G2P</code> contains hydrogen fuel-based power generation technology.</p><h4 id="Mapping-between-index-sets"><a class="docs-heading-anchor" href="#Mapping-between-index-sets">Mapping between index sets</a><a id="Mapping-between-index-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-between-index-sets" title="Permalink"></a></h4><p>Any model must construct relations between basic components in different categories.</p><p>For instance, it is important to consider that not all technology types exist in every spatial region. It is therefore necessary to have a method of mapping technologies to regions. A direct method is to maintain an index array of pairs consisting of a node matched with a technology:</p><pre><code class="language-julia hljs">Nodes_Techs = [ (&quot;R1&quot;,&quot;Hydro&quot;), (&quot;R1&quot;,&quot;CCGT&quot;),(&quot;R1&quot;,&quot;SolarPV&quot;), 
                (&quot;R2&quot;,&quot;SolarPV&quot;), (&quot;R2&quot;,&quot;Wind&quot;),
                (&quot;R3&quot;,&quot;Hydro&quot;), (&quot;R3&quot;,&quot;CCGT&quot;), (&quot;R3&quot;,&quot;SolarPV&quot;), (&quot;R3&quot;,&quot;Wind&quot;)]</code></pre><p>while for storage technologies the correspondence between location and available storage technologies is similarly defined through the array of pairs</p><pre><code class="language-julia hljs">Nodes_Storages = [ (&quot;R1&quot;,&quot;LIonBattery&quot;),
                   (&quot;R3&quot;,&quot;LIonBattery&quot;), (&quot;R3&quot;,&quot;PumpedHydro&quot;)]</code></pre><p>Numerous other similar subsets are used to define sets of constraints on particular combinations of technology, spatial location and so on. For example, <code>Nodes_Dispatch</code> is the subset of <code>Nodes_Techs</code> filtered to have only dispatchable technologies in the second component.</p><h3 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h3><p>The key decision variables of the model are shown here as</p><p><code>Julia variable name</code> - <em>Short descriptor</em> - <span>$\TeX$</span> notation</p><p>The notation <code>v[I,J]</code> indicates that the variable <code>v</code> is jointly indexed over <code>I</code>, <code>J</code>, etc.</p><h4 id="Generation-operational-variables"><a class="docs-heading-anchor" href="#Generation-operational-variables">Generation operational variables</a><a id="Generation-operational-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Generation-operational-variables" title="Permalink"></a></h4><ul><li><code>G[Nodes_Techs, Hours]</code> - <em>Generation level</em> - <span>$G_{(n,t),h}$</span><ul><li>Detail: Generation level - all generation technologies</li><li>Bounds: lower_bound=0</li><li>Units: MWh per time-interval; </li></ul></li><li><code>G_UP[Nodes_Dispatch, Hours]</code> - <em>Generation upshift</em> - <span>$G^{\uparrow}_{(n,t),h}$</span><ul><li>Detail: Generation level change upwards</li><li>Bound: lower_bound=0</li><li>Units: MWh per time-interval; </li></ul></li><li><code>G_DO[Nodes_Dispatch, Hours]</code> - <em>Generation downshift</em> - <span>$G^{\downarrow}_{(n,t),h}$</span><ul><li>Detail: Generation level change downwards</li><li>Bound: lower_bound=0</li><li>Units: MWh per time-interval; </li></ul></li><li><code>G_REZ[REZones,Hours]</code> - <em>Generation renewable</em> - <span>$G^{\text{REZ}}_{z,h}$</span><ul><li>Detail: Generation level - renewable energy zone tech. &amp; storage</li><li>Bound: lower_bound=0</li><li>Units: MWh per time-interval; </li><li><strong>Note</strong>: This is a &#39;book-keeping&#39; variable for each renewable energy zone (REZ, <code>REZones</code>) that aggregates operational variables at each hour.</li></ul></li><li><code>G_TxZ[TxZones,Hours]</code> - <em>Generation transmission zones</em> - <span>$G^{\text{TxZ}}_{z,h}$</span><ul><li>Detail: Generation level - transmission zone tech. &amp; storage</li><li>Bound: lower_bound=0</li><li>Units: MWh per time-interval; </li><li><strong>Note</strong>: This is a &#39;book-keeping&#39; variable for each transmission zone (<code>TxZones</code>) that aggregates operational variables in each hour.</li></ul></li></ul><h4 id="Storage-operational-variables"><a class="docs-heading-anchor" href="#Storage-operational-variables">Storage operational variables</a><a id="Storage-operational-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Storage-operational-variables" title="Permalink"></a></h4><ul><li><code>STO_IN[Nodes_Storages, Hours]</code> - <em>Storage inflow</em> - <span>$STO^{\text{IN}}_{(n,sto),h}$</span><ul><li>Detail: Storage energy inflow</li><li>Bound: lower_bound=0</li><li>Units: MWh per time-interval; </li></ul></li><li><code>STO_OUT[Nodes_Storages, Hours]</code> - <em>Storage outflow</em> - <span>$STO^{\text{OUT}}_{(n,sto),h}$</span><ul><li>Detail: Storage energy outflow</li><li>Bound: lower_bound=0</li><li>Units: MWh per time-interval; </li></ul></li><li><code>STO_L[Nodes_Storages, Hours]</code> - <em>Storage level</em> - <span>$STO^{\text{L}}_{(n,sto),h}$</span><ul><li>Detail: Storage energy level</li><li>Bound: lower_bound=0</li><li>Units: MWh at a given time-interval; </li></ul></li></ul><h3 id="Generation-and-storage-capacity-variables"><a class="docs-heading-anchor" href="#Generation-and-storage-capacity-variables">Generation and storage capacity variables</a><a id="Generation-and-storage-capacity-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Generation-and-storage-capacity-variables" title="Permalink"></a></h3><ul><li><code>N_TECH[Nodes_Techs]</code> - <em>Technology capacity</em> - <span>$N^{\text{TECH}}_{(n,t)}$</span><ul><li>Detail: Generation technology capacity </li><li>Bound: lower_bound=0</li><li>Units: MW; </li></ul></li><li><code>N_STO_E[Nodes_Storages]</code> - <em>Storage build energy</em> - <span>$N^{\text{E}}_{(n,sto)}$</span><ul><li>Detail: Storage energy capacity</li><li>Bound: lower_bound=0</li><li>Units: MWh; </li></ul></li><li><code>N_STO_P[Nodes_Storages]</code> - <em>Storage capacity</em> - <span>$N^{\text{P}}_{(n,sto)}$</span><ul><li>Detail: Storage (charge/discharge) power capacity</li><li>Bound: lower_bound=0</li><li>Units: MW; </li></ul></li><li><code>N_SYNC[Nodes_SynCons]</code> - <em>SynCon capacity</em> - <span>$N^{\text{SYNC}}_{(n,s)}$</span><ul><li>Detail: Synchronous condenser capacity</li><li>Bound: lower_bound=0</li><li>Units: MW; </li></ul></li></ul><h4 id="Transmission-network-variables"><a class="docs-heading-anchor" href="#Transmission-network-variables">Transmission network variables</a><a id="Transmission-network-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Transmission-network-variables" title="Permalink"></a></h4><ul><li><code>FLOW[Arcs,Hours]</code> - <em>Internodal flow</em> - <span>$F_{(n_F,n_T),h}$</span><ul><li>Detail: Power flow between nodes in topology</li><li>Bound: free</li><li>Units: MWh; </li></ul></li><li><code>N_IC_EXP[Arcs]</code> - <em>Internodal flow expansion</em> - <span>$N^{\text{IC\_EXP}}_{(n_F,n_T)}$</span><ul><li>Detail: Power transmission (flow) capacity expansion betweeen zones</li><li>Bound: lower_bound=0</li><li>Units: MW; </li></ul></li><li><code>N_REZ_EXP[REZones]</code> - <em>Renewable capacity expand</em> - <span>$N^{\text{RX}}_z$</span><ul><li>Detail: Renewable technology transmission capacity built</li><li>Bound: lower_bound=0</li><li>Units: MW; </li></ul></li><li><code>N_REZ_EXP_TX[REZones]</code> - <em>REZ expand by transmission</em><ul><li>Detail: REZ transmission capacity built when transmission network is expanded</li><li>Bound: lower_bound=0</li><li>Units: MW; </li></ul></li></ul><h4 id="Hydrogen-production-operational-variables"><a class="docs-heading-anchor" href="#Hydrogen-production-operational-variables">Hydrogen production operational variables</a><a id="Hydrogen-production-operational-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrogen-production-operational-variables" title="Permalink"></a></h4><ul><li><code>H2_P2G[Nodes_P2G, Hours]</code> - <em>H2 power to gas</em> - <span>$H2^{\text{P2G}}_{(n,p),h}$</span><ul><li>Detail: Power-to-gas hydrogen production</li><li>Bound: lower_bound=0</li><li>Units: MWh per time-interval; </li></ul></li><li><code>H2_G2P[Nodes_G2P, Hours]</code> - <em>H2 gas to power</em> - <span>$H2^{\text{G2P}}_{(n,g),h}$</span><ul><li>Detail: Hydrogen Gas-to-power energy conversion</li><li>Bound: lower_bound=0</li><li>Units: MWh per time-interval; </li></ul></li><li><code>H2_GS_L[Nodes_GasStorages, Hours]</code> - <em>H2 storage level</em> - <span>$H2^{\text{GS\_L}}_{(n,p),h}$</span><ul><li>Detail: Current gas storage level</li><li>Bound: lower_bound=0</li><li>Units: tonne-H2 at a given time-interval; </li></ul></li><li><code>H2_GS_IN[Nodes_GasStorages, Hours]</code> - <em>H2 storage inflow</em> - <span>$H2^{\text{GS\_IN}}_{(n,p),h}$</span><ul><li>Detail: Current gas storage input</li><li>Bound: lower_bound=0</li><li>Units: tonne-H2 at a given time-interval; </li></ul></li><li><code>H2_GS_OUT[Nodes_GasStorages, Hours]</code> - <em>H2 storage outflow</em> - <span>$H2^{\text{GS\_OUT}}_{(n,p),h}$</span><ul><li>Detail: Current gas storage output</li><li>Bound: lower_bound=0</li><li>Units: tonne-H2 at a given time-interval; </li></ul></li></ul><h4 id="Hydrogen-capacity-variables"><a class="docs-heading-anchor" href="#Hydrogen-capacity-variables">Hydrogen capacity variables</a><a id="Hydrogen-capacity-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrogen-capacity-variables" title="Permalink"></a></h4><ul><li><code>N_P2G[Nodes_P2G]</code> - <em>H2 P2G capacity</em> - <span>$N^{\text{P2G}}_{(n,p)}$</span><ul><li>Detail:  Power-to-gas capacity</li><li>Bound: lower_bound=0</li><li>Units: MW; </li></ul></li><li><code>N_G2P[Nodes_G2P]</code> - <em>H2 G2P capacity</em> - <span>$N^{\text{G2P}}_{(n,g)}$</span><ul><li>Detail: Gas-to-power capacity</li><li>Bound: lower_bound=0</li><li>Units: MW; </li></ul></li><li><code>N_GS[Nodes_GasStorages]</code> - <em>H2 storage capacity</em> - <span>$N^{\text{GS}}_{(n,gs)}$</span><ul><li>Detail: Gas storage capacity</li><li>Bound: lower_bound=0</li><li>Units; tonne-H2 ; </li></ul></li></ul><h3 id="Objective-function"><a class="docs-heading-anchor" href="#Objective-function">Objective function</a><a id="Objective-function-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-function" title="Permalink"></a></h3><p>The default objective function represents the total system cost. It has an operational component and a capacity investment component. We will write</p><p class="math-container">\[Z = Z^{\text{cap}} + \sum_{h \in \text{Hours}} Z_h^{\text{op}}\]</p><p>where each cost component comprises further subcomponents, as outlined next.</p><h4 id="Operational-costs"><a class="docs-heading-anchor" href="#Operational-costs">Operational costs</a><a id="Operational-costs-1"></a><a class="docs-heading-anchor-permalink" href="#Operational-costs" title="Permalink"></a></h4><p>For each time step index <span>$h \in \text{Hours}$</span>, operational costs <span>$Z_h^{\text{op}}$</span> are the sum of applicable variable costs (typically on a cost-per-MWh basis) for</p><ul><li>generation, due to <ul><li>operation and maintenance (O&amp;M) : <span>$vc$</span></li><li>fuel : <span>$fc$</span></li><li>carbon emissions : <span>$co2$</span></li></ul></li><li>storage charge and discharge<ul><li>operation and maintenance (O&amp;M) : <span>$vc$</span></li></ul></li><li>hydrogen production and hydrogen-fuelled power generation<ul><li>operation and maintenance (O&amp;M) : <span>$vc$</span></li></ul></li></ul><p>Mathematically,</p><p class="math-container">\[\begin{align*}
Z_h^{\text{op}} &amp;= 
 \sum_{n \in \text{Nodes}} \sum_{t \in \text{Techs}} (vc_{(n,t)} + \eta_{(n,t)} fc_{(n,t)} + co2_{(n,t)}) G_{(n,t),h}\\
&amp;  +  \sum_{n \in \text{Nodes}} \sum_{sto \in \text{Storages}} vc_{(n,sto)} (STO^{\text{IN}}_{(n,sto),h} + STO^{\text{OUT}}_{(n,sto),h}) \\
&amp;  +  \sum_{n \in \text{Nodes}} \left[ \sum_{p \in \text{P2G}} vc_{(n,p)} H2^{\text{P2G}}_{(n,p),h} + \sum_{g \in \text{G2P}} vc_{(n,g)} H2^{\text{G2P}}_{(n,g),h} \right]               
\end{align*}\]</p><p>where the parameter <span>$\eta$</span> is a conversion efficiency of fuel to electrical power (storage round-trip efficiencies are handled in constraints).</p><p>In code, the objective function is</p><pre><code class="language-julia hljs">@objective(m, Min, Z)
@constraint(m, ObjectiveFunction, Z ==
sum(MarginalCost[n,t] * G[(n,t),h] for (n,t) in Nodes_Dispatch, h in Hours)

+ sum(MarginalCost[n,sto] * (STO_OUT[(n,sto),h] + STO_IN[(n,sto),h]) for (n,sto) in Nodes_Storages, h in Hours)

+ sum(MarginalCost[n,p2g] * H2_P2G[(n,p2g),h] for (n,p2g) in Nodes_P2G, h in Hours)
+ sum(MarginalCost[n,g2p] * H2_G2P[(n,g2p),h] for (n,g2p) in Nodes_G2P, h in Hours)
...</code></pre><p>where <code>MarginalCost</code> encapsulates the cost components above, and the sum over all time steps is represented. Note the use of particular mapping subsets (e.g. <code>Nodes_Dispatch</code>) to refine the summation to only the terms with applicable data.</p><p>Additional operational terms for load following costs are also included as</p><pre><code class="language-julia hljs">+ LoadIncreaseCost[n,t] * sum(G_UP[(n,t),h] for (n,t) in Nodes_Dispatch, h in Hours2)
+ LoadDecreaseCost[n,t] * sum(G_DO[(n,t),h] for (n,t) in Nodes_Dispatch, h in Hours)
...</code></pre><p>that serve as soft-penalty proxies for the relative flexibility of different dispatchable generation technologies.</p><h4 id="Capacity-investment-costs"><a class="docs-heading-anchor" href="#Capacity-investment-costs">Capacity investment costs</a><a id="Capacity-investment-costs-1"></a><a class="docs-heading-anchor-permalink" href="#Capacity-investment-costs" title="Permalink"></a></h4><p>For each modelling year, the fixed cost (annual) and the investment cost (amortised relative to the lifetime of the technology) are combined to form <span>$Z^{\text{cap}}$</span>, where</p><p class="math-container">\[Z^{\text{cap}} = Z^{\text{fix}} + Z^{\text{inv}}.\]</p><p>Here</p><p class="math-container">\[\begin{align*}
Z^{\text{inv}} &amp;= 
     \sum_{n \in \text{Nodes}} \sum_{t \in \text{Techs}} ic_{(n,t)} N^{\text{TECH}}_{(n,t)} \\
  &amp;+ \sum_{n \in \text{Nodes}} \sum_{sto \in \text{Techs}} ic^P_{(n,sto)} N^{\text{P}}_{(n,sto)} + ic^E_{(n,sto)} N^{\text{E}}_{(n,sto)} \\
  &amp;+ \sum_{n \in \text{Nodes}} \sum_{s \in \text{SynCons}} ic^{SYNC}_{(n,s)} N^{\text{SYNC}}_{(n,s)} \\
  &amp;+ \sum_{n \in \text{Nodes}} \left[ \sum_{p \in \text{P2G}} ic^{P2G}_{(n,p)} N^{\text{P2G}}_{(n,p)} +  \sum_{g \in \text{G2P}} ic^{G2P}_{(n,g)} N^{\text{G2P}}_{(n,g)}
  +  \sum_{gs \in \text{GasSto}} ic^{GS}_{(n,gs)} N^{\text{GS}}_{(n,gs)}  \right] \\
  &amp;+ \sum_{(n_F,n_T) \in \text{Arcs}} ic^{IC\_EXP}_{(n_F,n_T)} N^{\text{IC\_EXP}}_{(n_F,n_T)}
\end{align*}\]</p><p>where the parameters <span>$ic$</span> refer to the present year investment costs. The objective term <span>$Z^{\text{fix}}$</span> is analogously defined after replacing investment costs with fixed costs.</p><p>Continuing from above, the following terms are appear in the objective function as</p><pre><code class="language-julia hljs">+ sum(InvestmentCost[n,t] * N_TECH[(n,t)] for (n,t) in Nodes_Techs_New)

+ sum(InvestmentCostPower[n,sto] * N_STO_P[(n,sto)] for (n,sto) in Nodes_Storages_New)
+ sum(InvestmentCostEnergy[n,sto] * N_STO_E[(n,sto)] for (n,sto) in Nodes_Storages_New)

+ sum(InvestmentCostSynCon[n,syn] * N_SYNC[(n,syn)] for (n,syn) in Nodes_SynCons)

+ sum(InvestmentCost[n,p2g] * N_P2G[(n,p2g)] for (n,p2g) in Nodes_P2G)
+ sum(InvestmentCost[n,g2p] * N_G2P[(n,g2p)] for (n,g2p) in Nodes_G2P)
+ sum(InvestmentCost[n,gs] * N_GS[(n,gs)] for (n,gs) in Nodes_GasStorages)

+ sum(ArcWeight[from,to]*InvestmentCostTransExp[from,to] * N_IC_EXP[(from,to)] for (from,to) in Arcs)

+ sum(FixedCost[n,t] * N_TECH[(n,t)] for (n,t) in Nodes_Techs)
+ sum(FixedCost[n,sto] * N_STO_P[(n,sto)] for (n,sto) in Nodes_Storages)

+ sum(FixedCost[n,p2g] * N_P2G[(n,p2g)] for (n,p2g) in Nodes_P2G)
+ sum(FixedCost[n,g2p] * N_G2P[(n,g2p)] for (n,g2p) in Nodes_G2P)
+ sum(FixedCost[n,gs] * N_GS[(n,gs)] for (n,gs) in Nodes_GasStorages)</code></pre><p>Note that while this formulation does not explicitly display discounting factors, these are applied in a separate pre-processing step.</p><h3 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h3><p>The model constraints are given here in both mathematical form and code implementation form.</p><p>For compactness we abbreviate <code>Nodes</code> to <span>$N$</span>, <code>Techs</code> to <span>$T$</span>, <code>Storages</code> to <span>$S$</span>, and <code>Arcs</code> to <span>$A$</span>. </p><p>In the code formulation, constants of the form <code>CapAdd[:CapacitySymbol][i,j,...]</code> denote capacity quantities from the optimal capacity values from the model&#39;s solution in the previous time-step. Their use is to distinguish new capacity decision variables from prior capacity expansion data. Note that in the mathematical formulation there is no separate term corresponding to <code>CapAdd</code>. Instead, the capacity variables (e.g. <span>$N^{\text{TECH}}$</span>) should be read as being inclusive of prior capacity expansion values, unless otherwise stated.</p><p>The parameter <span>$\tau$</span>, or <code>time_ratio</code>, is used to link energy variables and quantities (in MWh) to capacity (in MW). The constant relates generation levels during one time-step to energy on an hourly basis (MWh per hour). For example, a half-hourly time-step resolution means <code>time_ratio = 1/2</code> while an hour time-step resolution has <code>time_ratio = 1</code>.</p><h4 id="Energy-balance-and-load"><a class="docs-heading-anchor" href="#Energy-balance-and-load">Energy balance and load</a><a id="Energy-balance-and-load-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-balance-and-load" title="Permalink"></a></h4><p><em>Definition of REZone generation book-keeping variables</em>: for each <span>$z \in$</span> <code>REZones</code>,</p><p class="math-container">\[G^{\text{REZ}}_{z,h} = 
    \sum_{t | (z,t) \in N \times T} G_{(z,t),h}
    + \sum_{sto | (z,sto) \in N \times S} (STO^{\text{IN}}_{(z,sto),h} - STO^{\text{OUT}}_{(z,sto),h}) \]</p><pre><code class="language-julia hljs">@constraint(m, REZoneGen[rez=REZones,h=Hours],
    G_REZ[rez,h] ==
        sum(G[(z,t),h] for (z,t) in Nodes_Techs if z == rez)
        +  sum(STO_OUT[(q,sto),h] - STO_IN[(q,sto),h] for (q,sto) in Nodes_Storages if q == rez)
);</code></pre><p><em>Definition of TxZone generation book-keeping variables</em>: for each <span>$z \in$</span> <code>TxZones</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[G^{\text{TxZ}}_{(z,t),h} = 
    \sum_{t | (z,t) \in N \times T} G_{(n,t),h}
    + \sum_{sto | (z,sto) \in N \times S} (STO^{\text{IN}}_{(z,sto),h} - STO^{\text{OUT}}_{(z,sto),h}) \\
    + \sum_{(rez,t) \in N \times T \, | \; rez \, \uparrow z } G^{\text{REZ}}_{rez,h} - \sum_{(n_F,n_T) \in A \, | \, n_F = z } F_{(n_F,n_T),h} \]</p><p>where <span>$rez \, \uparrow z$</span>  means the renewable enegy zone <span>$rez$</span> is connected to the transmission zone <span>$z$</span>. </p><pre><code class="language-julia hljs">@constraint(m, TxZoneGen[zone=TxZones,h=Hours],
    G_TxZ[zone,h] ==
        sum(G[(z,t),h] for (z,t) in Nodes_Techs if z == zone)
        +  sum(STO_OUT[(z,sto),h] - STO_IN[(z,sto),h] for (z,sto) in Nodes_Storages if z == zone)
        +  sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)
        -  sum(FLOW[(from,to),h] for (from,to) in Arcs if from == zone)
);</code></pre><p><em>Energy balance at each demand node: supply equals or exceeds demand</em>: for each <span>$n \in$</span> <code>DemandZones</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[G^{\text{TxZ}}_{(n,t),h} +  \sum_{g \in \text{G2P}}  H2^{\text{G2P}}_{(n,g),h}
\geq 
\alpha^{\text{Tx}}  \left[ \widehat{D}_{n,h} +  \sum_{p \in \text{P2G}}  H2^{\text{P2G}}_{(n,p),h} \right]\]</p><p>where <span>$\widehat{D}$</span> is the array of hourly demands at nodes, and <span>$\alpha^{\text{Tx}}$</span> is a constant factor accounting for transmission line losses.</p><pre><code class="language-julia hljs">@constraint(m, EnergyBalance[n=DemandZones,h=Hours],
    sum(G_TxZ[zone,h] for (zone, d) in Nodes_Demand if d == n)
    + sum(H2_G2P[(zone,g2p),h] for (zone,g2p) in Nodes_G2P if zone == n)
    &gt;=
    loss_factor_tx*(
        Load[n,h]
        + sum(H2_P2G[(zone,p2g),h] for (zone,p2g) in Nodes_P2G if zone == n))
);</code></pre><p><em>Energy flow reflexive constraint</em>: for each <span>$(n_F,n_T) \in$</span> <code>Arcs</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[    F_{(n_F,n_T),h} = - F_{(n_T,n_F),h}\]</p><pre><code class="language-julia hljs">@constraint(m, FlowEnergyReflex[(from,to)=Arcs,h=Hours; from in Arcs_From],
    FLOW[(from,to),h] + FLOW[(to,from),h] == 0
);</code></pre><p><em>Energy flow bounds</em>: for each <span>$(n_F,n_T) \in$</span> <code>Arcs</code> and <span>$h \in$</span> <code>Hours</code>, </p><p class="math-container">\[    F_{(n_F,n_T),h} \leq \tau \left( \widehat{C}^{\text{Tx}}_{(n_F,n_T)} + N^{\text{IC\_EXP}}_{(n_F,n_T)} \right)\]</p><p>where <span>$\widehat{C}^{\text{Tx}}$</span> denotes existing capacity in transmission.</p><pre><code class="language-julia hljs">@constraint(m, FlowEnergyUpperBound[(from,to)=Arcs,h=Hours],
    FLOW[(from,to),h] &lt;= time_ratio * ( TransferCapacity[(from,to)] + N_IC_EXP[(from,to)] + CapAdd[:N_IC_EXP][(from,to)])
);</code></pre><p><em>Energy flow expansion symmetry</em>: for each <span>$(n_F,n_T) \in$</span> <code>Arcs</code>,</p><p class="math-container">\[N^{\text{IC\_EXP}}_{(n_F,n_T)} = N^{\text{IC\_EXP}}_{(n_T,n_F)}\]</p><pre><code class="language-julia hljs">@constraint(m, FlowEnergySymmetry[(from,to)=Arcs; from in Arcs_From],
    N_IC_EXP[(from,to)] == N_IC_EXP[(to,from)]
);</code></pre><p><em>Generation level start</em>: for each <span>$(n,t) \in$</span> <code>Nodes_Dispatch</code>,</p><p class="math-container">\[    G_{(n,t),1} = G^{\uparrow}_{(n,t),1}\]</p><pre><code class="language-julia hljs">@constraint(m, GenLevelStart[(n,t)=Nodes_Dispatch],
            G[(n,t),Hours[1]] == G_UP[(n,t),Hours[1]]
);</code></pre><p><em>Generation level dynamics</em>: for each <span>$(n,t) \in$</span> <code>Nodes_Dispatch</code>, and for <span>$h \in$</span> <code>Hours</code>, <span>$h \neq 1$</span>,</p><p class="math-container">\[    G_{(n,t),h} = G_{(n,t),h-1} + G^{\uparrow}_{(n,t),h} - G^{\downarrow}_{(n,t),h}\]</p><pre><code class="language-julia hljs">@constraint(m, GenLevelUpdate[(n,t)=Nodes_Dispatch,h=Hours2],
    G[(n,t),h] == G[(n,t),h-1] + G_UP[(n,t),h] - G_DO[(n,t),h]
);</code></pre><p><em>Variable upper bound on dispatchable generation by capacity</em>: for each <span>$(n,t) \in$</span> <code>Nodes_Dispatch</code>, and for <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[    G_{(n,t),h} \leq \tau \cdot \widehat{C}^{\text{Derate}}_{(n,t),h} N^{\text{TECH}}_{(n,t)}\]</p><p>where <span>$\widehat{C}^{\text{Derate}}$</span> denotes capacity derating depending on generation technology type and hour-dependent characteristics (such as seasonal temperature factors).</p><pre><code class="language-julia hljs">@constraint(m, MaxGenerationDisp[(n,t)=Nodes_Dispatch,h=Hours],
    G[(n,t),h] &lt;= CapacityDerating[n,t,h] * time_ratio * (N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)])
);</code></pre><p><em>Variable upper bound on non-dispatchable generation by capacity</em>: for each <span>$(n,t) \in$</span> <code>Nodes_Avail_Techs</code>, and for <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[G_{(n,t),h} \leq \tau \cdot \widehat{C}^{\text{Avail}}_{(n,t),h} N^{\text{TECH}}_{(n,t)}\]</p><p>where <span>$\widehat{C}^{\text{Avail}}$</span> denotes the availability of a variable renewable source (a value between 0 and 1 inclusive).</p><pre><code class="language-julia hljs">@constraint(m, MaxGenerationNonDisp[(n,t)=Nodes_Avail_Techs,h=Hours],
    G[(n,t),h] &lt;= Availability[n,t,h] * time_ratio * (N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)])
);</code></pre><p><em>Maximum capacity allowed</em>: for each <span>$(n,t) \in$</span> <code>Nodes_Techs</code>,</p><p class="math-container">\[    N^{\text{TECH}}_{(n,t)} \leq \widehat{N}^{\text{TECH}}_{(n,t)}\]</p><pre><code class="language-julia hljs">@constraint(m, MaxCapacityBound[(n,t)=Nodes_Techs; !(MaxCapacity[n,t] |&gt; ismissing)],
    N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)] &lt;= MaxCapacity[n,t]
);</code></pre><p><em>Maximum generated energy allowed</em>: for each <span>$(n,t) \in$</span> <code>Nodes_Techs</code>,</p><p class="math-container">\[    \sum_{h \in Hours} G_{(n,t),h} \leq \widehat{E}_{(n,t)}\]</p><pre><code class="language-julia hljs">@constraint(m, MaxEnergyGenerated[(n,t)=Nodes_Techs; !(MaxEnergy[n,t] |&gt; ismissing)],
    sum(G[(n,t),h] for h in Hours) &lt;= MaxEnergy[n,t]
);</code></pre><p><em>Renewable energy zone build limits</em>: for each <span>$z \in$</span> <code>REZones</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[\sum_{h \in Hours} G_{(z,t),h} \leq \tau \left( \widehat{C}^{\text{RX}}_z + N^{\text{RX}}_z \right)\]</p><p>where the <span>$\widehat{C}^{\text{RX}}$</span> term denotes the available hosting capacity in a zone before further expansion capacity <span>$N^{\text{RX}}$</span> is required.</p><pre><code class="language-julia hljs">@constraint(m, REZBuildLimits[rez=REZones,h=Hours],
    sum(G[(z,t),h] for (z,t) in Nodes_Avail_Techs if z == rez)
        &lt;= time_ratio*(TotalBuildCap[rez] +  N_REZ_EXP[rez] + CapAdd[:N_REZ_EXP][rez])
);</code></pre><p><em>Renewable energy zone expansion limits</em>: for each <span>$z \in$</span> <code>REZones</code>,</p><p class="math-container">\[N^{\text{RX}}_z \leq \widehat{N}^{\text{RX}}_z \]</p><pre><code class="language-julia hljs">@constraint(m, REZExpansionBound[rez=REZones],
    N_REZ_EXP[rez] + trunc(CapAdd[:N_REZ_EXP][rez]) &lt;= ExpansionLimit_REZ[rez]
);</code></pre><h4 id="Operational-conditions-and-constraints"><a class="docs-heading-anchor" href="#Operational-conditions-and-constraints">Operational conditions and constraints</a><a id="Operational-conditions-and-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Operational-conditions-and-constraints" title="Permalink"></a></h4><p><em>Maximum ramp up rates</em>: for each <span>$(n,t) \in$</span> <code>Nodes_RampingTechs</code>, and for <span>$h \in$</span> <code>Hours</code>, <span>$h \neq 1$</span>,</p><p class="math-container">\[    G^{\uparrow}_{(n,t),h}  \leq \tau \; \widehat{C}^{\uparrow}_t\]</p><p>where <span>$\widehat{C}^{\uparrow}$</span> denotes technology-specific ramp-up rates.</p><pre><code class="language-julia hljs">@constraint(m, RampingUpLimits[(n,t)=Nodes_RampingTechs, h=Hours2],
    G_UP[(n,t),h] &lt;= time_ratio * MaxRampUpPerHour[t]
);</code></pre><p><em>Maximum ramp down rates</em>: for each <span>$(n,t) \in$</span> <code>Nodes_RampingTechs</code>, and for <span>$h \in$</span> <code>Hours</code>, <span>$h \neq 1$</span>,</p><p class="math-container">\[    G^{\downarrow}_{(n,t),h}  \leq \tau \; \widehat{C}^{\downarrow}_t\]</p><p>where <span>$\widehat{C}^{\downarrow}$</span> denotes technology-specific ramp-up rates.</p><pre><code class="language-julia hljs">@constraint(m, RampingDownLimits[(n,t)=Nodes_RampingTechs, h=Hours2],
    G_DO[(n,t),h] &lt;= time_ratio * MaxRampDownPerHour[t]
)</code></pre><p><em>Operating reserve margin</em>: for particular regions <span>$dr \in$</span> <code>DemandRegions</code> and for all <span>$h \in$</span> <code>Hours</code>, the margin between available power generation and total capacity must remain greater than or equal to the applicable operating reserve.</p><pre><code class="language-julia hljs">@constraint(m, OperatingReserve[dr=DemandRegions, h=Hours],
    sum( CapacityDerating[n,t,h] * time_ratio * (N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)]) - G[(n,t),h]
        for (n,t) in Nodes_Dispatch if node2DemReg[n] == dr)
    + sum( PeakContribution[n,t] * time_ratio * (N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)])
        for (n,t) in Nodes_Avail_Techs if node2DemReg[n] == dr)  # or replace `Nodes_Avail_Techs` with `setdiff(Nodes_Avail_Techs,Nodes_Dispatch)`
    + sum( sqrt(Efficiency[n,sto])*STO_L[(n,sto), h]
        for (n,sto) in Nodes_Storages if node2DemReg[n] == dr)
    &gt;= time_ratio * OperatingReserve[dr]
);</code></pre><p><em>Minimum stable generation levels</em>: certain generation technologies must remain above a prescribed level as part of maintaining a stable operating state; for each <span>$(n,t) \in$</span> <code>Nodes_Dispatch</code>, and for <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[    G_{(n,t),h} \geq \tau \cdot \widehat{SG}_{(n,t)} \cdot \widehat{C}^{\text{Derate}}_{(n,t),h} N^{\text{TECH}}_{(n,t)}\]</p><p>where <span>$\widehat{SG}$</span> is a fraction between 0 and 1 denoting the proportion of available capacity that should be operational and supplying power.</p><pre><code class="language-julia hljs">@constraint(m, MinStableGeneration[(n,t)=keys(MinStableGen), h=Hours; !(MinStableGen[n,t] |&gt; ismissing)],
    G[(n,t),h] &gt;= MinStableGen[n,t] * CapacityDerating[n,t,h] * time_ratio * (N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)])
);</code></pre><h4 id="Requirements-for-renewable-generation"><a class="docs-heading-anchor" href="#Requirements-for-renewable-generation">Requirements for renewable generation</a><a id="Requirements-for-renewable-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Requirements-for-renewable-generation" title="Permalink"></a></h4><p><em>Minimum yearly renewables requirement</em>: for each demand region <span>$n \in$</span> <code>DemandRegions</code>, we require that a specified proportion of power is generated from variable renewable sources. </p><pre><code class="language-julia hljs">@constraint(m, MinRES[n=DemandRegions],
    sum(
        sum(G[(z,t),h] for (z,t) in Nodes_Renew if z == zone)  # Any renewable TxZone-level tech.
        + sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)
    for (zone, d) in Nodes_Demand if node2DemReg[d] == n
    for h in Hours
    )
    &gt;=
    (min_res_dict[n]/100)*(
        sum(
            sum(G[(z,t),h] for (z,t) in Nodes_Techs if z == zone)
            + sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)
        for (zone, d) in Nodes_Demand if node2DemReg[d] == n
        for h in Hours
        )
    )
);</code></pre><p><em>Minimum yearly renewables requirement for whole-of-system</em>: across the whole-of-system demand, we require that a specified proportion of power is generated from variable renewable sources. </p><pre><code class="language-julia hljs">@constraint(m, MinRESsystem,
    sum(
        sum(
            sum(G[(z,t),h] for (z,t) in Nodes_Renew if z == zone)  # Any renewable TxZone-level tech.
            + sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)
            for (zone, d) in Nodes_Demand if node2DemReg[d] == n
        for h in Hours)
    for n in DemandRegions)
        &gt;=
        (MinimumRenewShare/100)*sum(
            sum(
                sum(G[(z,t),h] for (z,t) in Nodes_Techs if z == zone)
                + sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)
                for (zone, d) in Nodes_Demand if node2DemReg[d] == n
            for h in Hours)
        for n in DemandRegions)
);</code></pre><h4 id="Storage-technologies"><a class="docs-heading-anchor" href="#Storage-technologies">Storage technologies</a><a id="Storage-technologies-1"></a><a class="docs-heading-anchor-permalink" href="#Storage-technologies" title="Permalink"></a></h4><p><em>Storage level dynamics: initial condition</em>: for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code>,</p><p class="math-container">\[STO^{\text{L}}_{(n,sto),1} = \sigma_0 \; \widehat{SoC}^{\text{max}}_{sto} \; N^{\text{E}}_{(n,sto)} + \rho_{(n,sto)}^{1/2} STO^{\text{IN}}_{(z,sto),1} - \rho_{(n,sto)}^{-1/2} STO^{\text{OUT}}_{(z,sto),1}\]</p><p>where</p><ul><li><span>$\sigma_0$</span> is the starting state-of-charge proportion (between 0 and 1, default value 0.5)</li><li><span>$\widehat{SoC}^{\text{max}}$</span> is the maximum state-of-charge proportion (between 0 and 1) relative to the nominal energy storage capacity, and</li><li><span>$\rho$</span> denotes storage round-trip efficiency.</li></ul><pre><code class="language-julia hljs">@constraint(m, StorageLevelStart[(n,sto)=Nodes_Storages],
    STO_L[(n,sto),Hours[1]]
        ==
    StartLevel[n,sto] * MaximumSoC[sto] * (N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)])
    +   sqrt(Efficiency[n,sto])*STO_IN[(n,sto), Hours[1]]
    - 1/sqrt(Efficiency[n,sto])*STO_OUT[(n,sto), Hours[1]]
);</code></pre><p><em>Storage end level equal to initial level</em>: for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code>,</p><p class="math-container">\[STO^{\text{L}}_{(n,sto),end} = \sigma_0 \; \widehat{SoC}^{\text{max}}_{sto} \; N^{\text{E}}_{(n,sto)}\]</p><pre><code class="language-julia hljs">@constraint(m, StorageLevelEnd[(n,sto)=Nodes_Storages],
    STO_L[(n,sto),Hours[end]]
        ==
    StartLevel[n,sto] * MaximumSoC[sto] * (N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)])
);</code></pre><p><em>Storage level dynamics</em>: for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code> and <span>$h \in$</span> <code>Hours</code>, <span>$h \neq 1$</span>,</p><p class="math-container">\[STO^{\text{L}}_{(n,sto),h} = STO^{\text{L}}_{(n,sto),h-1} + \rho_{(n,sto)}^{1/2} STO^{\text{IN}}_{(n,sto),h} - \rho_{(n,sto)}^{-1/2} STO^{\text{OUT}}_{(n,sto),h}\]</p><pre><code class="language-julia hljs">@constraint(m, StorageBalance[(n,sto)=Nodes_Storages,h=Hours2],
    STO_L[(n,sto), h]
    ==
    STO_L[(n,sto), h-1]
    +   sqrt(Efficiency[n,sto])*STO_IN[(n,sto), h]
    - (1/sqrt(Efficiency[n,sto]))*STO_OUT[(n,sto), h]
);</code></pre><p><em>Storage energy capacity</em>: for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[STO^{\text{L}}_{(n,sto),h} \leq \widehat{SoC}^{\text{max}}_{sto} \; N^{\text{E}}_{(n,sto)}\]</p><pre><code class="language-julia hljs">@constraint(m, MaxLevelStorage[(n,sto)=Nodes_Storages,h=Hours],
    STO_L[(n,sto),h] &lt;= MaximumSoC[sto] * (N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)])
);</code></pre><p><em>Storage maximum inflow</em>: for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[STO^{\text{IN}}_{(n,sto),h} \leq \tau  N^{\text{P}}_{(n,sto)}\]</p><pre><code class="language-julia hljs">@constraint(m, MaxWithdrawStorage[(n,sto)=Nodes_Storages,h=Hours],
    STO_IN[(n,sto),h] &lt;= time_ratio * (N_STO_P[(n,sto)] + CapAdd[:N_STO_P][(n,sto)])
);</code></pre><p><em>Storage generation outflow by capacity</em>: for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[STO^{\text{OUT}}_{(n,sto),h} \leq \tau  N^{\text{P}}_{(n,sto)}\]</p><pre><code class="language-julia hljs">@constraint(m, MaxGenerationStorage[(n,sto)=Nodes_Storages,h=Hours],
    STO_OUT[(n,sto),h] &lt;= time_ratio * (N_STO_P[(n,sto)] + CapAdd[:N_STO_P][(n,sto)])
);</code></pre><p><em>Storage: maximum energy allowed</em>: impose an energy capacity upper bound for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code>;</p><pre><code class="language-julia hljs">if !(isDictAllMissing(dtr.parameters[:MaxEnergy]))
    @constraint(m, MaxEnergyStorage[(n,sto)=Nodes_Storages; !(MaxEnergy[n,sto] |&gt; ismissing)],
        N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)] &lt;= MaxEnergy[n,sto]
    );
end</code></pre><p><em>Storage: maximum power allowed</em>: impose a power capacity upper bound for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code>;</p><pre><code class="language-julia hljs">@constraint(m, MaxPowerStorage[(n,sto)=Nodes_Storages; !(MaxCapacity[n,sto] |&gt; ismissing)],
    N_STO_P[(n,sto)] + CapAdd[:N_STO_P][(n,sto)] &lt;= MaxCapacity[n,sto]
);</code></pre><p><em>Storage: maximum energy-to-power ratio (duration)</em>: for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code>,</p><p class="math-container">\[(1 - \epsilon_{T}) \widehat{T}_{(n,sto)} N^{\text{P}}_{(n,sto)} \leq N^{\text{E}}_{(n,sto)} \leq (1 + \epsilon_{T})  \widehat{T}_{(n,sto)} N^{\text{P}}_{(n,sto)}\]</p><p>where <span>$\widehat{T}$</span> denotes a specified storage duration, and <span>$\epsilon_{T}$</span> is a constraint tolerance.</p><pre><code class="language-julia hljs">tol_EtoP = 0.01 ## Constraint tolerance for matching energy to power ratio

@constraint(m, EnergyToPowerRatioUp[(n,sto)=Nodes_Storages; !(MaxEtoP_ratio[n,sto] |&gt; ismissing)],
    N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)] &lt;= (1 + tol_EtoP) * MaxEtoP_ratio[n,sto] * (N_STO_P[(n,sto)] + CapAdd[:N_STO_P][(n,sto)])
);</code></pre><pre><code class="language-julia hljs">@constraint(m, EnergyToPowerRatioLo[(n,sto)=Nodes_Storages; !(MaxEtoP_ratio[n,sto] |&gt; ismissing)],
    N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)] &gt;= (1 - tol_EtoP) * MaxEtoP_ratio[n,sto] * (N_STO_P[(n,sto)] + CapAdd[:N_STO_P][(n,sto)])
);</code></pre><p><em>Storage: maximum outflow - no more than level of last period</em>: for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code> and <span>$h \in$</span> <code>Hours</code>, <span>$h \neq 1$</span>,</p><p class="math-container">\[\rho_{(n,sto)}^{-1/2} STO^{\text{OUT}}_{(n,sto),h} \leq STO^{\text{L}}_{(n,sto),h-1}\]</p><pre><code class="language-julia hljs">@constraint(m, MaxOutflowStorage[(n,sto)=Nodes_Storages,h=Hours2],
    (1/sqrt(Efficiency[n,sto]))*STO_OUT[(n,sto),h] &lt;= STO_L[(n,sto),h-1]
);</code></pre><p><em>Storage: maximum inflow - no more than energy capacity minus level of last period</em>: for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code> and <span>$h \in$</span> <code>Hours</code>, <span>$h \neq 1$</span>,</p><p class="math-container">\[\rho_{(n,sto)}^{1/2} STO^{\text{IN}}_{(n,sto),h} \leq \widehat{SoC}^{\text{max}}_{sto} N^{\text{E}}_{(n,sto)} - STO^{\text{L}}_{(n,sto),h-1}\]</p><pre><code class="language-julia hljs">@constraint(m, MaxInflowStorage[(n,sto)=Nodes_Storages,h=Hours2],
    sqrt(Efficiency[n,sto])*STO_IN[(n,sto),h] &lt;= MaximumSoC[sto] * (N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)]) - STO_L[(n,sto),h-1]
);</code></pre><p><em>Storage: maximum annual cycles - equivalent number of full discharges less than annual cycle number</em>: for each <span>$(n,sto) \in$</span> <code>Nodes_Storages</code>,</p><p class="math-container">\[\sum_{h \in \text{Hours}} STO^{\text{OUT}}_{(n,sto),h} \leq \nu_{sto} \widehat{SoC}^{\text{max}}_{sto}  N^{\text{E}}_{(n,sto)}\]</p><p>where the total equivalent number of times the storage technology undergoes a full discharge is specified by <span>$\nu_{sto}$</span>.</p><pre><code class="language-julia hljs">@constraint(m, MaxYearlyDischargeCycles[(n,sto)=Nodes_Storages; haskey(AnnualCycleNumber,sto)],
    sum(STO_OUT[(n,sto),h] for h in Hours) &lt;= AnnualCycleNumber[sto] * MaximumSoC[sto] * (N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)])
);</code></pre><h4 id="Hydrogen-technologies"><a class="docs-heading-anchor" href="#Hydrogen-technologies">Hydrogen technologies</a><a id="Hydrogen-technologies-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrogen-technologies" title="Permalink"></a></h4><p><em>Hydrogen: minimum yearly lower bound on power-to-gas</em>: for each <span>$(n,p) \in$</span> <code>Nodes_P2G</code>, </p><p class="math-container">\[\sum_{h \in \text{Hours}} H2^{\text{P2G}}_{(n,p),h} \geq \widehat{D}^{\text{H2}}_{(n,p2g)}\]</p><p>where <span>$\widehat{D}^{\text{H2}}$</span> denotes annual hydrogen production demand at particular spatial locations for a given electrolyser tecnhnology.</p><pre><code class="language-julia hljs">@constraint(dtr.model, MinYearlyP2G[(n,p2g)=Nodes_P2G],
    sum(H2_P2G[(n,p2g),h] for h in Hours) &gt;= H2Demand[n,p2g]
);</code></pre><p><em>Hydrogen: constant hourly lower bound on power-to-gas technology</em>: for each <span>$(n,p) \in$</span> <code>Nodes_P2G</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[H2^{\text{P2G}}_{(n,p),h} \geq \widehat{CF}^{\text{LB}}_n \frac{\widehat{D}^{\text{H2}}_{(n,p2g)}}{| \text{Hours} | } \]</p><p>where <span>$| \text{Hours} |$</span> is the number of time-steps (typically 8760 hours per year) and <span>$\widehat{CF}^{\text{LB}}$</span> is capacity factor lower bound data for typical plant operation.</p><pre><code class="language-julia hljs">@constraint(dtr.model, MinHourlyP2G_AE[(n,p2g)=Nodes_P2G_AE, h=Hours],
    H2_P2G[(n,p2g),h] &gt;= AE_Capacity_Factor_LB*(H2Demand[n,p2g]/periods)
);</code></pre><pre><code class="language-julia hljs">@constraint(dtr.model, MinHourlyP2G_PEM[(n,p2g)=Nodes_P2G_PEM, h=Hours],
    H2_P2G[(n,p2g),h] &gt;= PEM_Capacity_Factor_LB*(H2Demand[n,p2g]/periods)
);</code></pre><p><em>Hydrogen: variable upper bound on power-to-gas</em>: for each <span>$(n,p) \in$</span> <code>Nodes_P2G</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[H2^{\text{P2G}}_{(n,p),h} \leq \widehat{CF}^{\text{UB}}_n N^{\text{P2G}}_{(n,p)}\]</p><p>where <span>$\widehat{CF}^{\text{UB}}$</span> is capacity factor upper bound data for typical plant operation.</p><pre><code class="language-julia hljs">@constraint(dtr.model, MaxP2G[(n,p2g)=Nodes_P2G,h=Hours],
    H2_P2G[(n,p2g),h] &lt;= time_ratio * H2_P2G_Capacity_Factor_UB * (N_P2G[(n,p2g)] + CapAdd[:N_P2G][(n,p2g)])
);</code></pre><p><em>Hydrogen: variable upper bound on gas-to-power</em>: for each <span>$(n,g) \in$</span> <code>Nodes_G2P</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[H2^{\text{G2P}}_{(n,g),h} \leq N^{\text{G2P}}_{(n,g)}\]</p><pre><code class="language-julia hljs">@constraint(dtr.model, MaxG2P[(n,g2p)=Nodes_G2P,h=Hours],
    H2_G2P[(n,g2p),h] &lt;= time_ratio * (N_G2P[(n,g2p)] + CapAdd[:N_G2P][(n,g2p)])
);</code></pre><p><em>Hydrogen: capacity factor upper bound on gas-to-power</em>: for each <span>$(n,g) \in$</span> <code>Nodes_G2P</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[\sum_{h \in \text{Hours}} H2^{\text{G2P}}_{(n,g),h} \leq  \widehat{CF}^{\text{UB}}_n  N^{\text{G2P}}_{(n,g)} | \text{Hours} | \]</p><pre><code class="language-julia hljs">@constraint(dtr.model, MaxCapFactorH2_G2P[(n,g2p)=Nodes_G2P],
    sum(H2_G2P[(n,g2p),h] for h in Hours) &lt;= RecipH2_CF_UB*length(Hours)*(N_G2P[(n,g2p)] + CapAdd[:N_G2P][(n,g2p)])
);</code></pre><p><em>Hydrogen: variable upper bound on gas storage</em>: for each <span>$(n,gs) \in$</span> <code>Nodes_GasStorages</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[  H2^{\text{GS\_L}}_{(n,gs),h} \leq N^{\text{GS}}_{(n,gs)}\]</p><pre><code class="language-julia hljs">@constraint(dtr.model, MaxLevelGasStorage[(n,gs)=Nodes_GasStorages,h=Hours],
    H2_GS_L[(n,gs),h] &lt;= N_GS[(n,gs)] + CapAdd[:N_GS][(n,p2g)]
);</code></pre><p><em>Hydrogen: conversion into gas storage</em>: for each <span>$(n,gs) \in$</span> <code>Nodes_GasStorages</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[H2^{\text{GS\_IN}}_{(n,gs),h} = \sum_{(n,g) \in N \times \text{P2G}} \frac{H2^{\text{P2G}}_{(n,p),h}}{\gamma_{(n,p)}}\]</p><p>where <span>$\gamma_{(n,g)}$</span> is a conversion factor between units of stored hydrogen and electricity consumption (typically <code>H2Conversion</code> = <span>$\gamma$</span> = 15.2 MWh / t-H2 ).</p><pre><code class="language-julia hljs">@constraint(dtr.model, GasStorageIn[(n,gs)=Nodes_GasStorages,h=Hours],
    H2_GS_IN[(n,gs),h] == sum(H2_P2G[(n,p2g),h]/H2Conversion[n,p2g] for (n,p2g) in Nodes_P2G)
);</code></pre><p><em>Hydrogen: conversion out of gas storage</em>: for each <span>$(n,gs) \in$</span> <code>Nodes_GasStorages</code> and <span>$h \in$</span> <code>Hours</code>,</p><p class="math-container">\[H2^{\text{GS\_OUT}}_{(n,gs),h} = \sum_{(n,g) \in N \times \text{G2P}} \frac{H2^{\text{G2P}}_{(n,g),h}}{\gamma_{(n,g)}}\]</p><pre><code class="language-julia hljs">@constraint(dtr.model, GasStorageOut[(n,gs)=Nodes_GasStorages,h=Hours],
    H2_GS_OUT[(n,gs),h] == sum(H2_G2P[(n,g2p),h]/H2Conversion[n,g2p] for (n,g2p) in Nodes_G2P)
);</code></pre><p><em>Hydrogen: gas storage mass balance</em>: for each <span>$(n,gs) \in$</span> <code>Nodes_GasStorages</code> and <span>$h \in$</span> <code>Hours</code>, <span>$h \neq 1$</span>,</p><p class="math-container">\[ H2^{\text{GS\_L}}_{(n,gs),h} =  H2^{\text{GS\_L}}_{(n,gs),h-1} + H2^{\text{GS\_IN}}_{(n,gs),h} - H2^{\text{GS\_OUT}}_{(n,gs),h}\]</p><pre><code class="language-julia hljs">@constraint(dtr.model, GasStorageBalance[(n,gs)=Nodes_GasStorages,h=Hours2],
    H2_GS_L[(n,gs), h] == H2_GS_L[(n,gs), h-1] + H2_GS_IN[(n,gs), h] - H2_GS_OUT[(n,gs), h]
);</code></pre><p><em>Hydrogen: gas storage balance at first time-steps</em>: for each <span>$(n,gs) \in$</span> <code>Nodes_GasStorages</code>,</p><p class="math-container">\[H2^{\text{GS\_L}}_{(n,gs),1} = \sigma_0 \; N^{\text{GS}}_{(n,gs)} + H2^{\text{GS\_IN}}_{(n,gs),1} - H2^{\text{GS\_OUT}}_{(n,gs),1},\]</p><pre><code class="language-julia hljs">@constraint(dtr.model, GasStorageBalanceFirstHours[(n,gs)=Nodes_GasStorages],
    H2_GS_L[(n,gs), Hours[1]] == StartLevel[n,gs] * ( N_GS[(n,gs)] + CapAdd[:N_GS][(n,gs)]) + H2_GS_IN[(n,gs),Hours[1]] - H2_GS_OUT[(n,gs),Hours[1]]  # 
);</code></pre><p><em>Hydrogen: gas storage end level equal to initial level</em>: for each <span>$(n,gs) \in$</span> <code>Nodes_GasStorages</code>,</p><p class="math-container">\[H2^{\text{GS\_L}}_{(n,gs),1} = \sigma_0 \; N^{\text{GS}}_{(n,gs)}\]</p><pre><code class="language-julia hljs">@constraint(dtr.model, GasStorageLevelEnd[(n,gs)=Nodes_GasStorages],
    H2_GS_L[(n,gs), Hours[end]] == StartLevel[n,gs] * ( N_GS[(n,gs)] + CapAdd[:N_GS][(n,gs)])
);</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../quick_start_guide/">« Quick Start Guide</a><a class="docs-footer-nextpage" href="../../api/public/">Public API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 3 November 2022 06:03">Thursday 3 November 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
