var documenterSearchIndex = {"docs":
[{"location":"tutorials/intro_page/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorials/intro_page/","page":"Introduction","title":"Introduction","text":"All the tutorials.","category":"page"},{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Dieter.jl creates a JuMP optimization model.","category":"page"},{"location":"tutorials/optmodel/#Model-formulation","page":"Model formulation","title":"Model formulation","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Pages = [\"optmodel.md\"]\nDepth = 3","category":"page"},{"location":"tutorials/optmodel/#The-optimization-model","page":"Model formulation","title":"The optimization model","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The Dieter.jl package contains Julia functions to generate JuMP linear programming model instances. Each model has a system cost-minimising objective, with  energy and power variables representing technology capacities and operational states. ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"While there are degrees of flexibility around the final problem formulation, there are some core structures that remain invariant across models.","category":"page"},{"location":"tutorials/optmodel/#Index-sets","page":"Model formulation","title":"Index sets","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Each optimization model is structured around some key indexing sets related to","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Temporal\nSpatial\nTransmission\nTechnological","category":"page"},{"location":"tutorials/optmodel/#Temporal","page":"Model formulation","title":"Temporal","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The time indexing of DIETER is typically over 8760 hours of a single full year. The start and end day of the year itself is not assumed.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For example, in the code we have something akin to","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"hoursInYear = 8760\nTimestep = 1\nHours = 1:Timestep:hoursInYear\n# [1, 2, ..., 8759, 8760]","category":"page"},{"location":"tutorials/optmodel/#Spatial","page":"Model formulation","title":"Spatial","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The model is represented spatially as a network graph, where generation and demand activity is located at nodes (or vertices), while connections between nodes are represented as directed edges (or lines). A typical node in the model represents a region of a system in which we aggregate the operations and capacities of technologies. We may assign to a node a demand requirement, for electricity or another commodity, that must be satisfied by energy production.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For example, we might define a set of nodes as a simple array of string labels:","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Nodes = [\"R1\", \"R2\", \"R3\"]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"We use both the terms \"region\" and \"zone\" to refer to spatial entities, often using \"region\" to refer to the largest spatial grouping in the model, and a \"zone\" to mean a sub-region. Specific examples are transmission zones (abbreviated TxZones) and renewable energy zones (abbreviated REZones, used for aggregating variable renewable energy resources).","category":"page"},{"location":"tutorials/optmodel/#Transmission","page":"Model formulation","title":"Transmission","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Transmission lines transfer electrical power from supply to demand. As mentioned, regions or zones are connected by lines, represented as ordered pairs of spatial nodes. We refer to these lines as Arcs in the models: an arc may represent what in reality is a transmission link comprised of one or more physical transmission lines.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"A basic line representation is a pair consisting of two spatial regions. We collect all lines in the set Arcs","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For example:","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Arcs = [(\"R1\",\"R2\"), (\"R2\", \"R1\"), (\"R2,R3\"), (\"R2\", \"R3\")]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Here the network topology is a linear graph (R1 ⇆ R2 ⇆ R3) where both directions of a connection between regions are explicitly included in the set.","category":"page"},{"location":"tutorials/optmodel/#Technological","page":"Model formulation","title":"Technological","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Technologies are sub-categorised as follows:","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Conventional (fossil fuel-based) electrical generators\nVariable renewable electrical generators\nEnergy storage devices\nHydrogen production devices","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The set Techs contains variable and dispatchable electricity generation types, for example","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Techs = [\"Wind\", \"SolarPV\", \"Hydro\", \"CCGT\", \"OCGT\"]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"and is distinguished from the set Storages of energy storage technology types, for example","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storages = [\"LIonBattery\", \"PumpedHydro\", \"CAES\", \"RedoxBattery\"]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"since the model constraints differ for these two categories.","category":"page"},{"location":"tutorials/optmodel/#Mapping-between-index-sets","page":"Model formulation","title":"Mapping between index sets","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Any model must construct relations between basic components in different categories.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For instance, it is important to consider that not all technology types exist in every spatial region. It is therefore necessary to have a method of mapping technologies to regions. A direct method is to maintain an index array of pairs consisting of a node matched with a technology:","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Nodes_Techs = [ (\"R1\",\"Hydro\"), (\"R1\",\"CCGT\"),(\"R1\",\"SolarPV\"), \n                (\"R2\",\"SolarPV\"), (\"R2\",\"Wind\"),\n                (\"R3\",\"Hydro\"), (\"R3\",\"CCGT\"), (\"R3\",\"SolarPV\"), (\"R3\",\"Wind\")]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"while for storage technologies the correspondence between location and available storage technologies is similarly defined through the array of pairs","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Nodes_Storages = [ (\"R1\",\"LIonBattery\"),\n                   (\"R3\",\"LIonBattery\"), (\"R3\",\"PumpedHydro\")]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Numerous other similar subsets are used to define sets of constraints on particular combinations of technology, spatial location and so on. For example, Nodes_Dispatch is the subset of Nodes_Techs filtered to have only dispatchable technologies in the second component.","category":"page"},{"location":"tutorials/optmodel/#Variables","page":"Model formulation","title":"Variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The key decision variables of the model are shown here as","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Julia variable name - Short descriptor - TeX notation","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The notation v[I,J] indicates that the variable v is jointly indexed over I, J, etc.","category":"page"},{"location":"tutorials/optmodel/#Generation-operational-variables","page":"Model formulation","title":"Generation operational variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"G[Nodes_Techs, Hours] - Generation level - G_(nt)h\nDetail: Generation level - all generation technologies\nBounds: lower_bound=0\nUnits: MWh per time-interval; \nG_UP[Nodes_Dispatch, Hours] - Generation upshift\nDetail: Generation level change upwards\nBound: lower_bound=0\nUnits: MWh per time-interval; \nG_DO[Nodes_Dispatch, Hours] - Generation downshift\nDetail: Generation level change downwards\nBound: lower_bound=0\nUnits: MWh per time-interval; \nG_REZ[REZones,Hours] - Generation renewable - G^textREZ_zh\nDetail: Generation level - renewable energy zone tech. & storage\nBound: lower_bound=0\nUnits: MWh per time-interval; \nNote: This is a 'book-keeping' variable for each renewable energy zone (REZ, REZones) that aggregates operational variables at each hour.\nG_TxZ[TxZones,Hours] - Generation transmission zones - G^textTxZ_zh\nDetail: Generation level - transmission zone tech. & storage\nBound: lower_bound=0\nUnits: MWh per time-interval; \nNote: This is a 'book-keeping' variable for each transmission zone (TxZones) that aggregates operational variables in each hour.","category":"page"},{"location":"tutorials/optmodel/#Storage-operational-variables","page":"Model formulation","title":"Storage operational variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"STO_IN[Nodes_Storages, Hours] - Storage inflow - STO^textIN_(nsto)h\nDetail: Storage energy inflow\nBound: lower_bound=0\nUnits: MWh per time-interval; \nSTO_OUT[Nodes_Storages, Hours] - Storage outflow - STO^textOUT_(nsto)h\nDetail: Storage energy outflow\nBound: lower_bound=0\nUnits: MWh per time-interval; \nSTO_L[Nodes_Storages, Hours] - Storage level - STO^textL_(nsto)h\nDetail: Storage energy level\nBound: lower_bound=0\nUnits: MWh at a given time-interval; ","category":"page"},{"location":"tutorials/optmodel/#Generation-and-storage-capacity-variables","page":"Model formulation","title":"Generation and storage capacity variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"N_TECH[Nodes_Techs] - Technology capacity - N^textTECH_(nt)\nDetail: Generation technology capacity \nBound: lower_bound=0\nUnits: MW; \nN_STO_E[Nodes_Storages] - Storage build energy - N^textE_(nsto)\nDetail: Storage energy capacity\nBound: lower_bound=0\nUnits: MWh; \nN_STO_P[Nodes_Storages] - Storage capacity - N^textP_(nsto)\nDetail: Storage (charge/discharge) power capacity\nBound: lower_bound=0\nUnits: MW; \nN_SYNC[Nodes_SynCons] - SynCon capacity - N^textSYNC_(ns)\nDetail: Synchronous condenser capacity\nBound: lower_bound=0\nUnits: MW; ","category":"page"},{"location":"tutorials/optmodel/#Transmission-network-variables","page":"Model formulation","title":"Transmission network variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"FLOW[Arcs,Hours] - Internodal flow - F_(n_Fn_T)h\nDetail: Power flow between nodes in topology\nBound: free\nUnits: MWh; \nN_IC_EXP[Arcs] - Internodal flow expansion - N^textIC_EXP_(n_Fn_T)\nDetail: Power transmission (flow) capacity expansion betweeen zones\nBound: lower_bound=0\nUnits: MW; \nN_REZ_EXP[REZones] - Renewable capacity expand\nDetail: Renewable technology transmission capacity built\nBound: lower_bound=0\nUnits: MW; \nN_REZ_EXP_TX[REZones] - REZ expand by transmission\nDetail: REZ transmission capacity built when transmission network is expanded\nBound: lower_bound=0\nUnits: MW; ","category":"page"},{"location":"tutorials/optmodel/#Hydrogen-production-operational-variables","page":"Model formulation","title":"Hydrogen production operational variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"H2_P2G[Nodes_P2G, Hours] - H2 power to gas - H2^textP2G_(np)h\nDetail: Power-to-gas hydrogen production\nBound: lower_bound=0\nUnits: MWh per time-interval; \nH2_G2P[Nodes_G2P, Hours] - H2 gas to power - H2^textG2P_(ng)h\nDetail: Hydrogen Gas-to-power energy conversion\nBound: lower_bound=0\nUnits: MWh per time-interval; \nH2_GS_L[Nodes_GasStorages, Hours] - H2 storage level - H2^textGS_L_(np)h\nDetail: Current gas storage level\nBound: lower_bound=0\nUnits: tonne-H2 at a given time-interval; \nH2_GS_IN[Nodes_GasStorages, Hours] - H2 storage inflow\nDetail: Current gas storage input\nBound: lower_bound=0\nUnits: tonne-H2 at a given time-interval; \nH2_GS_OUT[Nodes_GasStorages, Hours] - H2 storage outflow\nDetail: Current gas storage output\nBound: lower_bound=0\nUnits: tonne-H2 at a given time-interval; ","category":"page"},{"location":"tutorials/optmodel/#Hydrogen-capacity-variables","page":"Model formulation","title":"Hydrogen capacity variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"N_P2G[Nodes_P2G] - H2 P2G capacity - N^textP2G_(np)\nDetail:  Power-to-gas capacity\nBound: lower_bound=0\nUnits: MW; \nN_G2P[Nodes_G2P] - H2 G2P capacity - N^textG2P_(ng)\nDetail: Gas-to-power capacity\nBound: lower_bound=0\nUnits: MW; \nN_GS[Nodes_GasStorages] - H2 storage capacity - N^textGS_(ngs)\nDetail: Gas storage capacity\nBound: lower_bound=0\nUnits; tonne-H2 ; ","category":"page"},{"location":"tutorials/optmodel/#Objective-function","page":"Model formulation","title":"Objective function","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The default objective function represents the total system cost. It has an operational component and a capacity investment component. We will write","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Z = Z^textcap + sum_h in textHours Z_h^textop","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where each cost component comprises further subcomponents, as outlined next.","category":"page"},{"location":"tutorials/optmodel/#Operational-costs","page":"Model formulation","title":"Operational costs","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For each time step index h in textHours, operational costs Z_h^textop are the sum of applicable variable costs (typically on a cost-per-MWh basis) for","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"generation, due to \noperation and maintenance (O&M) : vc\nfuel : fc\ncarbon emissions : co2\nstorage charge and discharge\noperation and maintenance (O&M) : vc\nhydrogen production and hydrogen-fuelled power generation\noperation and maintenance (O&M) : vc","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Mathematically,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"beginalign*\nZ_h^textop = \n sum_n in textNodes sum_t in textTechs (vc_(nt) + eta_(nt) fc_(nt) + co2_(nt)) G_(nt)h\n  +  sum_n in textNodes sum_sto in textStorages vc_(nsto) (STO^textIN_(nsto)h + STO^textOUT_(nsto)h) \n  +  sum_n in textNodes left sum_p in textP2G vc_(np) H2^textP2G_(np)h + sum_g in textG2P vc_(ng) H2^textG2P_(ng)h right               \nendalign*","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where the parameter eta is a conversion efficiency of fuel to electrical power (storage round-trip efficiencies are handled in constraints).","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"In code, the objective function is","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@objective(m, Min, Z)\n@constraint(m, ObjectiveFunction, Z ==\nsum(MarginalCost[n,t] * G[(n,t),h] for (n,t) in Nodes_Dispatch, h in Hours)\n\n+ sum(MarginalCost[n,sto] * (STO_OUT[(n,sto),h] + STO_IN[(n,sto),h]) for (n,sto) in Nodes_Storages, h in Hours)\n\n+ sum(MarginalCost[n,p2g] * H2_P2G[(n,p2g),h] for (n,p2g) in Nodes_P2G, h in Hours)\n+ sum(MarginalCost[n,g2p] * H2_G2P[(n,g2p),h] for (n,g2p) in Nodes_G2P, h in Hours)\n...","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where MarginalCost encapsulates the cost components above, and the sum over all time steps is represented. Note the use of particular mapping subsets (e.g. Nodes_Dispatch) to refine the summation to only the terms with applicable data.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Additional operational terms for load following costs are also included as","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"+ LoadIncreaseCost[n,t] * sum(G_UP[(n,t),h] for (n,t) in Nodes_Dispatch, h in Hours2)\n+ LoadDecreaseCost[n,t] * sum(G_DO[(n,t),h] for (n,t) in Nodes_Dispatch, h in Hours)\n...","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"that serve as soft-penalty proxies for the relative flexibility of different dispatchable generation technologies.","category":"page"},{"location":"tutorials/optmodel/#Capacity-investment-costs","page":"Model formulation","title":"Capacity investment costs","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For each modelling year, the fixed cost (annual) and the investment cost (amortised relative to the lifetime of the technology) are combined to form Z^textcap, where","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Z^textcap = Z^textfix + Z^textinv","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Here","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"beginalign*\nZ^textinv = \n     sum_n in textNodes sum_t in textTechs ic_(nt) N^textTECH_(nt) \n  + sum_n in textNodes sum_sto in textTechs ic^P_(nsto) N^textP_(nsto) + ic^E_(nsto) N^textE_(nsto) \n  + sum_n in textNodes sum_s in textSynCons ic^SYNC_(ns) N^textSYNC_(ns) \n  + sum_n in textNodes left sum_p in textP2G ic^P2G_(np) N^textP2G_(np) +  sum_g in textG2P ic^G2P_(ng) N^textG2P_(ng)\n  +  sum_gs in textGasSto ic^GS_(ngs) N^textGS_(ngs)  right \n  + sum_(n_Fn_T) in textArcs ic^IC_EXP_(n_Fn_T) N^textIC_EXP_(n_Fn_T)\nendalign*","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where the parameters ic refer to the present year investment costs. The objective term Z^textfix is analogously defined after replacing investment costs with fixed costs.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Continuing from above, the following terms are appear in the objective function as","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"+ sum(InvestmentCost[n,t] * N_TECH[(n,t)] for (n,t) in Nodes_Techs_New)\n\n+ sum(InvestmentCostPower[n,sto] * N_STO_P[(n,sto)] for (n,sto) in Nodes_Storages_New)\n+ sum(InvestmentCostEnergy[n,sto] * N_STO_E[(n,sto)] for (n,sto) in Nodes_Storages_New)\n\n+ sum(InvestmentCostSynCon[n,syn] * N_SYNC[(n,syn)] for (n,syn) in Nodes_SynCons)\n\n+ sum(InvestmentCost[n,p2g] * N_P2G[(n,p2g)] for (n,p2g) in Nodes_P2G)\n+ sum(InvestmentCost[n,g2p] * N_G2P[(n,g2p)] for (n,g2p) in Nodes_G2P)\n+ sum(InvestmentCost[n,gs] * N_GS[(n,gs)] for (n,gs) in Nodes_GasStorages)\n\n+ sum(ArcWeight[from,to]*InvestmentCostTransExp[from,to] * N_IC_EXP[(from,to)] for (from,to) in Arcs)\n\n+ sum(FixedCost[n,t] * N_TECH[(n,t)] for (n,t) in Nodes_Techs)\n+ sum(FixedCost[n,sto] * N_STO_P[(n,sto)] for (n,sto) in Nodes_Storages)\n\n+ sum(FixedCost[n,p2g] * N_P2G[(n,p2g)] for (n,p2g) in Nodes_P2G)\n+ sum(FixedCost[n,g2p] * N_G2P[(n,g2p)] for (n,g2p) in Nodes_G2P)\n+ sum(FixedCost[n,gs] * N_GS[(n,gs)] for (n,gs) in Nodes_GasStorages)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Note that while this formulation does not explicitly display discounting factors, these are applied in a separate pre-processing step.","category":"page"},{"location":"tutorials/optmodel/#Constraints","page":"Model formulation","title":"Constraints","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For compactness we abbreviate Nodes to N, Techs to T, Storages to S, and Arcs to A. ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Definition of REZone generation book-keeping variables: for z in REZones,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"G^textREZ_zh = \n    sum_t  (zt) in N times T G_(zt)h\n    + sum_sto  (zsto) in N times S (STO^textIN_(zsto)h - STO^textOUT_(zsto)h) ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, REZoneGen[rez=REZones,h=Hours],\n    G_REZ[rez,h] ==\n        sum(G[(z,t),h] for (z,t) in Nodes_Techs if z == rez)\n        +  sum(STO_OUT[(q,sto),h] - STO_IN[(q,sto),h] for (q,sto) in Nodes_Storages if q == rez)\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Definition of TxZone generation book-keeping variables: for z in TxZones and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"G^textTxZ_(zt)h = \n    sum_t  (zt) in N times T G_(nt)h\n    + sum_sto  (zsto) in N times S (STO^textIN_(zsto)h - STO^textOUT_(zsto)h) \n    + sum_(rezt) in N times T    rez  uparrow z  G^textREZ_rezh - sum_(n_Fn_T) in A    n_F = z  F_(n_Fn_T)h ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where rez  uparrow z  means the renewable enegy zone rez is connected to the transmission zone z. ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, TxZoneGen[zone=TxZones,h=Hours],\n    G_TxZ[zone,h] ==\n        sum(G[(z,t),h] for (z,t) in Nodes_Techs if z == zone)\n        +  sum(STO_OUT[(z,sto),h] - STO_IN[(z,sto),h] for (z,sto) in Nodes_Storages if z == zone)\n        +  sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)\n        -  sum(FLOW[(from,to),h] for (from,to) in Arcs if from == zone)\n);","category":"page"},{"location":"api/internal/#Internal-API","page":"Internal API Reference","title":"Internal API","text":"","category":"section"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [Dieter]\nPublic = false","category":"page"},{"location":"api/internal/#Dieter.calc_inv_storages!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.calc_inv_storages!","text":"Calculate the amortised investment cost of technologies from capital costs.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.calc_inv_tech!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.calc_inv_tech!","text":"Calculate the amortised investment cost of technologies from capital costs.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.calc_mc!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.calc_mc!","text":"Calculated marginal costs for plants including variable costs\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.convert_jump_container_to_df-Tuple{JuMP.Containers.DenseAxisArray}","page":"Internal API Reference","title":"Dieter.convert_jump_container_to_df","text":"Returns a DataFrame with the values of the variables from the JuMP container var. The column names of the DataFrame can be specified for the indexing columns in dim_names, and the name of the data value column by a Symbol value_col e.g. :Value\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.initialise_data_dir_structure-Tuple{Any}","page":"Internal API Reference","title":"Dieter.initialise_data_dir_structure","text":"Initialise a basic file structure for accessing the model data. The default directory structure is: <datapath>/ ├── base │   ├── availability.csv │   ├── load.csv │   ├── storages.csv │   └── technologies.csv ├── ev │   ├── ev.csv │   ├── evdemand.csv │   └── evpower.csv ├── h2 │   └── h2technologies.csv └── heat     ├── buildings.csv     ├── dhwdemand.csv     ├── heat.csv     ├── heatdemand.csv     ├── heattechnologies.csv     └── temperature.csv\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.initialise_set_relation_data!-Tuple{Any}","page":"Internal API Reference","title":"Dieter.initialise_set_relation_data!","text":"Create the mathematical set relations for doing set-correspondences in models.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.isDictAllMissing-Tuple{Dict}","page":"Internal API Reference","title":"Dieter.isDictAllMissing","text":"Check if a Dictionary has all missing values; if so, return true\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.map_dfheader_to_col-Tuple{DataFrames.DataFrame}","page":"Internal API Reference","title":"Dieter.map_dfheader_to_col","text":"Create a Dict from a DataFrame with the DataFrame column-names as keys and columns as values.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.map_idcol-Tuple{DataFrames.DataFrame, Int64}","page":"Internal API Reference","title":"Dieter.map_idcol","text":"Return a dictionary of Dicts from a DataFrame with column-names as keys, and each Dict has a key-value pair of idcols => data-value. Column symbols listed in `skipcols` are skipped.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14, z=2:5)\n4×3 DataFrame\n│ Row │ x     │ y     │ z     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 11    │ 2     │\n│ 2   │ 2     │ 12    │ 3     │\n│ 3   │ 3     │ 13    │ 4     │\n│ 4   │ 4     │ 14    │ 5     │\n\njulia> map_idcol(df, 1, skip_cols=[:z])\nDict{Symbol,Dict} with 1 entry:\n  :y => Dict(4=>14,2=>12,3=>13,1=>11)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.parse_base_technologies!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.parse_base_technologies!","text":"Expected Dieter model parameters read into dtr.parameters: ExistingCapacity, FuelCost, FixedCost, VariableCost, OvernightCost, CurtailmentCost, LoadIncreaseCost, LoadDecreaseCost, Lifetime, MaxCapacity, MaxEnergy, TechTypeCategory, Renewable, Dispatchable, FuelSource, Efficiency, CarbonContent, CO2_price\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.parse_file-Tuple{String}","page":"Internal API Reference","title":"Dieter.parse_file","text":"Parse a given data file and return the desired data in a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.split_df_tuple-Tuple{DataFrames.DataFrame, Symbol, Vector{Symbol}}","page":"Internal API Reference","title":"Dieter.split_df_tuple","text":"split_df_tuple is a function that transforms a DataFrame with a Tuple{N,M...} type column. It outputs an augmented DataFrame with the tuples split into two columns of type N, M... resp.\n\nThe function splits the column InputCol of type Tuple into individual columns named with OutputCols vector of Symbols. Note that the Symbols in OutputCols need to be of the name length and order to correspond to the splitting Tuples.\n\nArguments\n\ndf : a DataFrame\nInputCol : a Symbol for a column of type Tuple{Types...}\nOutputCols: a Vector of Symbols for new column names,\n\nReturns\n\n::DataFrame\n\nExamples\n\n```  julia> using DataFramesMeta, DataFrames\n\njulia> df = DataFrame(A_N = [(\"a\",1),(\"b\",2)], V = [8,9]);\n\njulia> splitdftuple(df, :AN, [:A, :N]) 2×4 DataFrame │ Row │ AN      │ V     │ A      │ N     │ │     │ Tuple…   │ Int64 │ String │ Int64 │ ├─────┼──────────┼───────┼────────┼───────┤ │ 1   │ (\"a\", 1) │ 8     │ a      │ 1     │ │ 2   │ (\"b\", 2) │ 9     │ b      │ 2     │  ```\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.table2df-Tuple{Any}","page":"Internal API Reference","title":"Dieter.table2df","text":"Function to convert an Array{Any,2} with a header row of column name strings to a DataFrame\n\nThanks: https://stackoverflow.com/questions/25894634/dataframe-from-array-with-header\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.tableToDict-Tuple{Matrix}","page":"Internal API Reference","title":"Dieter.tableToDict","text":"tableToDict(tab::Array{Any,2}; keycols::Array{Int64,1}=[1])\n\nCreate a dictionary from an array in table form, where the table tab has:\n\nkey-index or indices given in the keycol array (integer column position), and\nthe column names for data appear in the first row.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.update_dict!-Tuple{Dict{Symbol, Dict}, Symbol, Dict}","page":"Internal API Reference","title":"Dieter.update_dict!","text":"Update a data Dict, merging the data if present, adding data if not present\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.@def-Tuple{Any, Any}","page":"Internal API Reference","title":"Dieter.@def","text":"The def macro is used to build other macros that can insert the same block of Julia code into different parts of a program. This is macro is used to generate a standard set of fields inside a model type hierarchy. (Thanks: InfrastructureModels.jl; see http://www.stochasticlifestyle.com/type-dispatch-design-post-object-oriented-programming-julia/)\n\n\n\n\n\n","category":"macro"},{"location":"api/internal/#Dieter.@dm_fields-Tuple{}","page":"Internal API Reference","title":"Dieter.@dm_fields","text":"A macro for adding the basic fields to an AbstractDieterModel type definition.\n\n\n\n\n\n","category":"macro"},{"location":"#Dieter.jl","page":"Welcome Page","title":"Dieter.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = Dieter","category":"page"},{"location":"#Table-of-Contents","page":"Welcome Page","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Pages = [\"index.md\", \"tutorials/optmodel.md\"]\nDepth = 3","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"DIETER is the Dispatch and Investment Evaluation Tool with Endogenous Renewables, an open energy system model developed by the German Institute for Economic Research (DIW Berlin). The model is structured as a cost-minimising linear program that when solved to optimality will produce an hourly operation profile of an interconnected transmission system over a single year, including aspects such as","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"generator power output,\nstorage technology charge and discharge,\ntransmission flows,\nvariable renewable energy utilisation, and\nhydrogen electrolyser operation.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The model also decides on cost-optimal capacity expansion of relevant model technologies relative to the year under consideration. A higher level module for programmatically constructing the required data model is enabled by STABLE.jl.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"This code repository holds a derivative version of DIETER written using the Julia language and the JuMP algebraic modelling language (a Julia package). While the original version of DIETER is implemented in GAMS, Julia/JuMP enables a free and open-source implementation. Linear programming (LP) solvers are required to compute optimal solutions, and both free/open-source and commercial solver can be freely interchanged using interfaces via JuMP (commercial solvers such as the Gurobi LP solver may required for obtaining reasonable run times when solving large-scale problems).","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The DIETER.jl Julia/JuMP package has been developed at CSIRO within the Energy Systems research program. Thanks to Mario Kendziorski for an earlier version, as well as Wolf-Peter Schill.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"In keeping with the original version, DIETER.jl is open source and may be freely used and modified by anyone. Contributions are welcome. The code is licensed under the MIT License. Input data is licensed under the Creative Commons Attribution-ShareAlike 4.0 International Public License.","category":"page"},{"location":"#Model-code","page":"Welcome Page","title":"Model code","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For a quick overview, the model code can be directly viewed in the model.jl file.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Note that the model is (currently) lacking some features which exist in the GAMS model such as the representation of reserves and prosumage.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"General utility functions for handling DataFrames, Dicts and translations from JuMP data structures, useful independently of DIETER.jl, are to be found in the util.jl file.","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"To install this as a Julia module, download this repository to a sub-folder in, for example, your home folder e.g. ","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"dieter_path=joinpath(ENV[\"HOME\"],\"Dieter\")","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"In the julia REPL, run","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"import Pkg\nPkg.add(Pkg.PackageSpec(path=dieter_path; rev=\"dev\"))","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The argument rev=\"dev\" selects the git branch to use; change this to use your own alternative branch as required.","category":"page"},{"location":"api/public/#Public-API-Reference","page":"Public API Reference","title":"Public API Reference","text":"","category":"section"},{"location":"api/public/#Modeling","page":"Public API Reference","title":"Modeling","text":"","category":"section"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [Dieter]\nPages   = [\"Dieter.jl\",\n           \"model.jl\",\n           \"struct.jl\",\n           \"util.jl\",\n           \"base.jl\"]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/public/#Dieter.build_model!-Tuple{DieterModel}","page":"Public API Reference","title":"Dieter.build_model!","text":"Build the JuMP model describing the optimization problem, specifying the solver to use. The Timestep parameter should be 1 for half-hourly steps, 2 for hourly steps, and 4 for 2-hourly steps. The data must match the time-steps of the Timestep parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.InitialiseDieterModel-Tuple{Type, Dict{String}}","page":"Public API Reference","title":"Dieter.InitialiseDieterModel","text":"Default constructor for a Dieter model, initialised with the Model DataType and a user-specified data Dict associated with the model in the constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.initialise_data_file_dict!-Tuple{Dieter.AbstractDieterModel, String}","page":"Public API Reference","title":"Dieter.initialise_data_file_dict!","text":"Initialise the strings giving the file-path references to the model data. The argument sfx is the file suffix of each model data file. Currently, sfx can be either \"csv\" or \"sql\"\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.check_files_exist-Tuple{Dict{String, String}}","page":"Public API Reference","title":"Dieter.check_files_exist","text":"Given a Dict of keys => filenames, check at files exist\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.create_relation-Tuple{DataFrames.DataFrame, Symbol, Symbol, Symbol}","page":"Public API Reference","title":"Dieter.create_relation","text":"Using a DataFrame, create_relation returns a function that can be used to determine a 2-valued relation, that is, a set-to-set correspondence. DataFrame column-names (Symbols) are given that define the set tuples, and a third Indicator column-name is used to indicate set membership. The return type is a function that can be used with two \"sets\" A and B in tuple2_filter(func,A,B) = filter(x->func(x[1],x[2]), [(a,b) for a in A for b in B])\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.parse_data_to_model!-Tuple{Dieter.AbstractDieterModel}","page":"Public API Reference","title":"Dieter.parse_data_to_model!","text":"Build the data for the model, returning intermediate DataFrames containing parsed data. The function will not parse data where the corresponding model setting equals missing.\n\n\n\n\n\n","category":"method"}]
}
