var documenterSearchIndex = {"docs":
[{"location":"tutorials/intro_page/#Dieter-Tutorials","page":"Tutorials","title":"Dieter Tutorials","text":"","category":"section"},{"location":"tutorials/intro_page/","page":"Tutorials","title":"Tutorials","text":"All the tutorials.","category":"page"},{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Dieter.jl creates a JuMP optimization model.","category":"page"},{"location":"api/internal/#Internal-API","page":"Internal API Reference","title":"Internal API","text":"","category":"section"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [Dieter]\nPublic = false","category":"page"},{"location":"api/internal/#Dieter.calc_inv_storages!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.calc_inv_storages!","text":"Calculate the amortised investment cost of technologies from capital costs.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.calc_inv_tech!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.calc_inv_tech!","text":"Calculate the amortised investment cost of technologies from capital costs.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.calc_mc!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.calc_mc!","text":"Calculated marginal costs for plants including variable costs\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.convert_jump_container_to_df-Tuple{JuMP.Containers.DenseAxisArray}","page":"Internal API Reference","title":"Dieter.convert_jump_container_to_df","text":"Returns a DataFrame with the values of the variables from the JuMP container var. The column names of the DataFrame can be specified for the indexing columns in dim_names, and the name of the data value column by a Symbol value_col e.g. :Value\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.initialise_data_dir_structure-Tuple{Any}","page":"Internal API Reference","title":"Dieter.initialise_data_dir_structure","text":"Initialise a basic file structure for accessing the model data. The default directory structure is: <datapath>/ ├── base │   ├── availability.csv │   ├── load.csv │   ├── storages.csv │   └── technologies.csv ├── ev │   ├── ev.csv │   ├── evdemand.csv │   └── evpower.csv ├── h2 │   └── h2technologies.csv └── heat     ├── buildings.csv     ├── dhwdemand.csv     ├── heat.csv     ├── heatdemand.csv     ├── heattechnologies.csv     └── temperature.csv\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.initialise_set_relation_data!-Tuple{Any}","page":"Internal API Reference","title":"Dieter.initialise_set_relation_data!","text":"Create the mathematical set relations for doing set-correspondences in models.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.isDictAllMissing-Tuple{Dict{T, S} where {T, S}}","page":"Internal API Reference","title":"Dieter.isDictAllMissing","text":"Check if a Dictionary has all missing values; if so, return true\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.map_dfheader_to_col-Tuple{DataFrames.DataFrame}","page":"Internal API Reference","title":"Dieter.map_dfheader_to_col","text":"Create a Dict from a DataFrame with the DataFrame column-names as keys and columns as values.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.map_idcol-Tuple{DataFrames.DataFrame, Int64}","page":"Internal API Reference","title":"Dieter.map_idcol","text":"Return a dictionary of Dicts from a DataFrame with column-names as keys, and each Dict has a key-value pair of idcols => data-value. Column symbols listed in `skipcols` are skipped.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14, z=2:5)\n4×3 DataFrame\n│ Row │ x     │ y     │ z     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 11    │ 2     │\n│ 2   │ 2     │ 12    │ 3     │\n│ 3   │ 3     │ 13    │ 4     │\n│ 4   │ 4     │ 14    │ 5     │\n\njulia> map_idcol(df, 1, skip_cols=[:z])\nDict{Symbol,Dict} with 1 entry:\n  :y => Dict(4=>14,2=>12,3=>13,1=>11)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.parse_base_technologies!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.parse_base_technologies!","text":"Expected Dieter model parameters read into dtr.parameters: ExistingCapacity, FuelCost, FixedCost, VariableCost, OvernightCost, CurtailmentCost, LoadIncreaseCost, LoadDecreaseCost, Lifetime, MaxCapacity, MaxEnergy, TechTypeCategory, Renewable, Dispatchable, FuelSource, Efficiency, CarbonContent, CO2_price\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.parse_file-Tuple{String}","page":"Internal API Reference","title":"Dieter.parse_file","text":"Parse a given data file and return the desired data in a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.split_df_tuple-Tuple{DataFrames.DataFrame, Symbol, Vector{Symbol}}","page":"Internal API Reference","title":"Dieter.split_df_tuple","text":"split_df_tuple is a function that transforms a DataFrame with a Tuple{N,M...} type column. It outputs an augmented DataFrame with the tuples split into two columns of type N, M... resp.\n\nThe function splits the column InputCol of type Tuple into individual columns named with OutputCols vector of Symbols. Note that the Symbols in OutputCols need to be of the name length and order to correspond to the splitting Tuples.\n\nArguments\n\ndf : a DataFrame\nInputCol : a Symbol for a column of type Tuple{Types...}\nOutputCols: a Vector of Symbols for new column names,\n\nReturns\n\n::DataFrame\n\nExamples\n\n```  julia> using DataFramesMeta, DataFrames\n\njulia> df = DataFrame(A_N = [(\"a\",1),(\"b\",2)], V = [8,9]);\n\njulia> splitdftuple(df, :AN, [:A, :N]) 2×4 DataFrame │ Row │ AN      │ V     │ A      │ N     │ │     │ Tuple…   │ Int64 │ String │ Int64 │ ├─────┼──────────┼───────┼────────┼───────┤ │ 1   │ (\"a\", 1) │ 8     │ a      │ 1     │ │ 2   │ (\"b\", 2) │ 9     │ b      │ 2     │  ```\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.table2df-Tuple{Any}","page":"Internal API Reference","title":"Dieter.table2df","text":"Function to convert an Array{Any,2} with a header row of column name strings to a DataFrame\n\nThanks: https://stackoverflow.com/questions/25894634/dataframe-from-array-with-header\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.tableToDict-Tuple{Matrix{var\"#s226\"} where var\"#s226\"}","page":"Internal API Reference","title":"Dieter.tableToDict","text":"tableToDict(tab::Array{Any,2}; keycols::Array{Int64,1}=[1])\n\nCreate a dictionary from an array in table form, where the table tab has:\n\nkey-index or indices given in the keycol array (integer column position), and\nthe column names for data appear in the first row.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.update_dict!-Tuple{Dict{Symbol, Dict}, Symbol, Dict}","page":"Internal API Reference","title":"Dieter.update_dict!","text":"Update a data Dict, merging the data if present, adding data if not present\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.@def-Tuple{Any, Any}","page":"Internal API Reference","title":"Dieter.@def","text":"The def macro is used to build other macros that can insert the same block of Julia code into different parts of a program. This is macro is used to generate a standard set of fields inside a model type hierarchy. (Thanks: InfrastructureModels.jl; see http://www.stochasticlifestyle.com/type-dispatch-design-post-object-oriented-programming-julia/)\n\n\n\n\n\n","category":"macro"},{"location":"api/internal/#Dieter.@dm_fields-Tuple{}","page":"Internal API Reference","title":"Dieter.@dm_fields","text":"A macro for adding the basic fields to an AbstractDieterModel type definition.\n\n\n\n\n\n","category":"macro"},{"location":"#Dieter.jl","page":"Welcome Page","title":"Dieter.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = Dieter","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"api/public/#Public-API-Reference","page":"Public API Reference","title":"Public API Reference","text":"","category":"section"},{"location":"api/public/#Modeling","page":"Public API Reference","title":"Modeling","text":"","category":"section"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [Dieter]\nPages   = [\"Dieter.jl\",\n           \"model.jl\",\n           \"struct.jl\",\n           \"util.jl\",\n           \"base.jl\"]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/public/#Dieter.build_model!-Tuple{DieterModel}","page":"Public API Reference","title":"Dieter.build_model!","text":"Build the JuMP model describing the optimization problem, specifying the solver to use. The Timestep parameter should be 1 for half-hourly steps, 2 for hourly steps, and 4 for 2-hourly steps. The data must match the time-steps of the Timestep parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.InitialiseDieterModel-Tuple{Type, Dict{String, T} where T}","page":"Public API Reference","title":"Dieter.InitialiseDieterModel","text":"Default constructor for a Dieter model, initialised with the Model DataType and a user-specified data Dict associated with the model in the constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.initialise_data_file_dict!-Tuple{Dieter.AbstractDieterModel, String}","page":"Public API Reference","title":"Dieter.initialise_data_file_dict!","text":"Initialise the strings giving the file-path references to the model data. The argument sfx is the file suffix of each model data file. Currently, sfx can be either \"csv\" or \"sql\"\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.check_files_exist-Tuple{Dict{String, String}}","page":"Public API Reference","title":"Dieter.check_files_exist","text":"Given a Dict of keys => filenames, check at files exist\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.create_relation-Tuple{DataFrames.DataFrame, Symbol, Symbol, Symbol}","page":"Public API Reference","title":"Dieter.create_relation","text":"Using a DataFrame, create_relation returns a function that can be used to determine a 2-valued relation, that is, a set-to-set correspondence. DataFrame column-names (Symbols) are given that define the set tuples, and a third Indicator column-name is used to indicate set membership. The return type is a function that can be used with two \"sets\" A and B in tuple2_filter(func,A,B) = filter(x->func(x[1],x[2]), [(a,b) for a in A for b in B])\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.parse_data_to_model!-Tuple{Dieter.AbstractDieterModel}","page":"Public API Reference","title":"Dieter.parse_data_to_model!","text":"Build the data for the model, returning intermediate DataFrames containing parsed data. The function will not parse data where the corresponding model setting equals missing.\n\n\n\n\n\n","category":"method"}]
}
