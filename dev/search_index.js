var documenterSearchIndex = {"docs":
[{"location":"tutorials/intro_page/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorials/intro_page/","page":"Introduction","title":"Introduction","text":"All the tutorials.","category":"page"},{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Dieter.jl creates a JuMP optimization model.","category":"page"},{"location":"tutorials/optmodel/#Model-formulation","page":"Model formulation","title":"Model formulation","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Pages = [\"optmodel.md\"]\nDepth = 4","category":"page"},{"location":"tutorials/optmodel/#The-optimization-model","page":"Model formulation","title":"The optimization model","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The Dieter.jl package contains Julia functions to generate JuMP linear programming model instances. Each model has a system cost-minimising objective, with  energy and power variables representing technology capacities and operational states. ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"While there are degrees of flexibility around the final problem formulation, there are some core structures that remain invariant across models.","category":"page"},{"location":"tutorials/optmodel/#Index-sets","page":"Model formulation","title":"Index sets","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Each optimization model is structured around some key indexing sets related to","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Temporal\nSpatial\nTransmission\nTechnological","category":"page"},{"location":"tutorials/optmodel/#Temporal","page":"Model formulation","title":"Temporal","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The time indexing of DIETER is typically over 8760 hours of a single full year. The set of time-steps is written textHours or Hours. The start and end day of the year itself is not assumed.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For example, in the code we have something akin to","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"hoursInYear = 8760\nTimestep = 1\nHours = 1:Timestep:hoursInYear\n# [1, 2, ..., 8759, 8760]","category":"page"},{"location":"tutorials/optmodel/#Spatial","page":"Model formulation","title":"Spatial","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The model is represented spatially as a network graph, where generation and demand activity is located at nodes (or vertices), while connections between nodes are represented as directed edges (or lines). A typical node in the model represents a region of a system in which we aggregate the operations and capacities of technologies. We may assign to a node a demand requirement, for electricity or another commodity, that must be satisfied by energy production.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For example, we might define a set of nodes as a simple array of string labels:","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Nodes = [\"R1\", \"R2\", \"R3\"]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"We use both the terms \"region\" and \"zone\" to refer to spatial entities, often using \"region\" to refer to the largest spatial grouping in the model, and a \"zone\" to mean a sub-region. Specific examples are transmission zones (abbreviated TxZones) and renewable energy zones (abbreviated REZones, used for aggregating variable renewable energy resources).","category":"page"},{"location":"tutorials/optmodel/#Transmission","page":"Model formulation","title":"Transmission","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Transmission lines transfer electrical power from supply to demand. As mentioned, regions or zones are connected by lines, represented as ordered pairs of spatial nodes. We refer to these lines as Arcs in the models: an arc may represent what in reality is a transmission link comprised of one or more physical transmission lines.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"A basic line representation is a pair consisting of two spatial regions. We collect all lines in the set Arcs","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For example:","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Arcs = [(\"R1\",\"R2\"), (\"R2\", \"R1\"), (\"R2,R3\"), (\"R2\", \"R3\")]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Here the network topology is a linear graph (R1 ⇆ R2 ⇆ R3) where both directions of a connection between regions are explicitly included in the set.","category":"page"},{"location":"tutorials/optmodel/#Technological","page":"Model formulation","title":"Technological","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Technologies are sub-categorised as follows:","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Conventional (fossil fuel-based) electrical generators\nVariable renewable electrical generators\nEnergy storage devices\nHydrogen production devices","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The set Techs contains variable and dispatchable electricity generation types, for example","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Techs = [\"Wind\", \"SolarPV\", \"Hydro\", \"CCGT\", \"OCGT\"]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"and is distinguished from the set Storages of energy storage technology types, for example","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storages = [\"LIonBattery\", \"PumpedHydro\", \"CAES\", \"RedoxBattery\"]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"since the model constraints differ for these two categories.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"In the case of hydrogen technology, the set P2G contains hydrogen electrolysers, and G2P contains hydrogen fuel-based power generation technology.","category":"page"},{"location":"tutorials/optmodel/#Mapping-between-index-sets","page":"Model formulation","title":"Mapping between index sets","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Any model must construct relations between basic components in different categories.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For instance, it is important to consider that not all technology types exist in every spatial region. It is therefore necessary to have a method of mapping technologies to regions. A direct method is to maintain an index array of pairs consisting of a node matched with a technology:","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Nodes_Techs = [ (\"R1\",\"Hydro\"), (\"R1\",\"CCGT\"),(\"R1\",\"SolarPV\"), \n                (\"R2\",\"SolarPV\"), (\"R2\",\"Wind\"),\n                (\"R3\",\"Hydro\"), (\"R3\",\"CCGT\"), (\"R3\",\"SolarPV\"), (\"R3\",\"Wind\")]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"while for storage technologies the correspondence between location and available storage technologies is similarly defined through the array of pairs","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Nodes_Storages = [ (\"R1\",\"LIonBattery\"),\n                   (\"R3\",\"LIonBattery\"), (\"R3\",\"PumpedHydro\")]","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Numerous other similar subsets are used to define sets of constraints on particular combinations of technology, spatial location and so on. For example, Nodes_Dispatch is the subset of Nodes_Techs filtered to have only dispatchable technologies in the second component.","category":"page"},{"location":"tutorials/optmodel/#Variables","page":"Model formulation","title":"Variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The key decision variables of the model are shown here as","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Julia variable name - Short descriptor - TeX notation","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The notation v[I,J] indicates that the variable v is jointly indexed over I, J, etc.","category":"page"},{"location":"tutorials/optmodel/#Generation-operational-variables","page":"Model formulation","title":"Generation operational variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"G[Nodes_Techs, Hours] - Generation level - G_(nt)h\nDetail: Generation level - all generation technologies\nBounds: lower_bound=0\nUnits: MWh per time-interval; \nG_UP[Nodes_Dispatch, Hours] - Generation upshift - G^uparrow_(nt)h\nDetail: Generation level change upwards\nBound: lower_bound=0\nUnits: MWh per time-interval; \nG_DO[Nodes_Dispatch, Hours] - Generation downshift - G^downarrow_(nt)h\nDetail: Generation level change downwards\nBound: lower_bound=0\nUnits: MWh per time-interval; \nG_REZ[REZones,Hours] - Generation renewable - G^textREZ_zh\nDetail: Generation level - renewable energy zone tech. & storage\nBound: lower_bound=0\nUnits: MWh per time-interval; \nNote: This is a 'book-keeping' variable for each renewable energy zone (REZ, REZones) that aggregates operational variables at each hour.\nG_TxZ[TxZones,Hours] - Generation transmission zones - G^textTxZ_zh\nDetail: Generation level - transmission zone tech. & storage\nBound: lower_bound=0\nUnits: MWh per time-interval; \nNote: This is a 'book-keeping' variable for each transmission zone (TxZones) that aggregates operational variables in each hour.","category":"page"},{"location":"tutorials/optmodel/#Storage-operational-variables","page":"Model formulation","title":"Storage operational variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"STO_IN[Nodes_Storages, Hours] - Storage inflow - STO^textIN_(nsto)h\nDetail: Storage energy inflow\nBound: lower_bound=0\nUnits: MWh per time-interval; \nSTO_OUT[Nodes_Storages, Hours] - Storage outflow - STO^textOUT_(nsto)h\nDetail: Storage energy outflow\nBound: lower_bound=0\nUnits: MWh per time-interval; \nSTO_L[Nodes_Storages, Hours] - Storage level - STO^textL_(nsto)h\nDetail: Storage energy level\nBound: lower_bound=0\nUnits: MWh at a given time-interval; ","category":"page"},{"location":"tutorials/optmodel/#Generation-and-storage-capacity-variables","page":"Model formulation","title":"Generation and storage capacity variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"N_TECH[Nodes_Techs] - Technology capacity - N^textTECH_(nt)\nDetail: Generation technology capacity \nBound: lower_bound=0\nUnits: MW; \nN_STO_E[Nodes_Storages] - Storage build energy - N^textE_(nsto)\nDetail: Storage energy capacity\nBound: lower_bound=0\nUnits: MWh; \nN_STO_P[Nodes_Storages] - Storage capacity - N^textP_(nsto)\nDetail: Storage (charge/discharge) power capacity\nBound: lower_bound=0\nUnits: MW; \nN_SYNC[Nodes_SynCons] - SynCon capacity - N^textSYNC_(ns)\nDetail: Synchronous condenser capacity\nBound: lower_bound=0\nUnits: MW; ","category":"page"},{"location":"tutorials/optmodel/#Transmission-network-variables","page":"Model formulation","title":"Transmission network variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"FLOW[Arcs,Hours] - Internodal flow - F_(n_Fn_T)h\nDetail: Power flow between nodes in topology\nBound: free\nUnits: MWh; \nN_IC_EXP[Arcs] - Internodal flow expansion - N^textIC_EXP_(n_Fn_T)\nDetail: Power transmission (flow) capacity expansion betweeen zones\nBound: lower_bound=0\nUnits: MW; \nN_REZ_EXP[REZones] - Renewable capacity expand - N^textRX_z\nDetail: Renewable technology transmission capacity built\nBound: lower_bound=0\nUnits: MW; \nN_REZ_EXP_TX[REZones] - REZ expand by transmission\nDetail: REZ transmission capacity built when transmission network is expanded\nBound: lower_bound=0\nUnits: MW; ","category":"page"},{"location":"tutorials/optmodel/#Hydrogen-production-operational-variables","page":"Model formulation","title":"Hydrogen production operational variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"H2_P2G[Nodes_P2G, Hours] - H2 power to gas - H2^textP2G_(np)h\nDetail: Power-to-gas hydrogen production\nBound: lower_bound=0\nUnits: MWh per time-interval; \nH2_G2P[Nodes_G2P, Hours] - H2 gas to power - H2^textG2P_(ng)h\nDetail: Hydrogen Gas-to-power energy conversion\nBound: lower_bound=0\nUnits: MWh per time-interval; \nH2_GS_L[Nodes_GasStorages, Hours] - H2 storage level - H2^textGS_L_(np)h\nDetail: Current gas storage level\nBound: lower_bound=0\nUnits: tonne-H2 at a given time-interval; \nH2_GS_IN[Nodes_GasStorages, Hours] - H2 storage inflow - H2^textGS_IN_(np)h\nDetail: Current gas storage input\nBound: lower_bound=0\nUnits: tonne-H2 at a given time-interval; \nH2_GS_OUT[Nodes_GasStorages, Hours] - H2 storage outflow - H2^textGS_OUT_(np)h\nDetail: Current gas storage output\nBound: lower_bound=0\nUnits: tonne-H2 at a given time-interval; ","category":"page"},{"location":"tutorials/optmodel/#Hydrogen-capacity-variables","page":"Model formulation","title":"Hydrogen capacity variables","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"N_P2G[Nodes_P2G] - H2 P2G capacity - N^textP2G_(np)\nDetail:  Power-to-gas capacity\nBound: lower_bound=0\nUnits: MW; \nN_G2P[Nodes_G2P] - H2 G2P capacity - N^textG2P_(ng)\nDetail: Gas-to-power capacity\nBound: lower_bound=0\nUnits: MW; \nN_GS[Nodes_GasStorages] - H2 storage capacity - N^textGS_(ngs)\nDetail: Gas storage capacity\nBound: lower_bound=0\nUnits; tonne-H2 ; ","category":"page"},{"location":"tutorials/optmodel/#Objective-function","page":"Model formulation","title":"Objective function","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The default objective function represents the total system cost. It has an operational component and a capacity investment component. We will write","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Z = Z^textcap + sum_h in textHours Z_h^textop","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where each cost component comprises further subcomponents, as outlined next.","category":"page"},{"location":"tutorials/optmodel/#Operational-costs","page":"Model formulation","title":"Operational costs","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For each time step index h in textHours, operational costs Z_h^textop are the sum of applicable variable costs (typically on a cost-per-MWh basis) for","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"generation, due to \noperation and maintenance (O&M) : vc\nfuel : fc\ncarbon emissions : co2\nstorage charge and discharge\noperation and maintenance (O&M) : vc\nhydrogen production and hydrogen-fuelled power generation\noperation and maintenance (O&M) : vc","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Mathematically,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"beginalign*\nZ_h^textop = \n sum_n in textNodes sum_t in textTechs (vc_(nt) + eta_(nt) fc_(nt) + co2_(nt)) G_(nt)h\n  +  sum_n in textNodes sum_sto in textStorages vc_(nsto) (STO^textIN_(nsto)h + STO^textOUT_(nsto)h) \n  +  sum_n in textNodes left sum_p in textP2G vc_(np) H2^textP2G_(np)h + sum_g in textG2P vc_(ng) H2^textG2P_(ng)h right               \nendalign*","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where the parameter eta is a conversion efficiency of fuel to electrical power (storage round-trip efficiencies are handled in constraints).","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"In code, the objective function is","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@objective(m, Min, Z)\n@constraint(m, ObjectiveFunction, Z ==\nsum(MarginalCost[n,t] * G[(n,t),h] for (n,t) in Nodes_Dispatch, h in Hours)\n\n+ sum(MarginalCost[n,sto] * (STO_OUT[(n,sto),h] + STO_IN[(n,sto),h]) for (n,sto) in Nodes_Storages, h in Hours)\n\n+ sum(MarginalCost[n,p2g] * H2_P2G[(n,p2g),h] for (n,p2g) in Nodes_P2G, h in Hours)\n+ sum(MarginalCost[n,g2p] * H2_G2P[(n,g2p),h] for (n,g2p) in Nodes_G2P, h in Hours)\n...","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where MarginalCost encapsulates the cost components above, and the sum over all time steps is represented. Note the use of particular mapping subsets (e.g. Nodes_Dispatch) to refine the summation to only the terms with applicable data.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Additional operational terms for load following costs are also included as","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"+ LoadIncreaseCost[n,t] * sum(G_UP[(n,t),h] for (n,t) in Nodes_Dispatch, h in Hours2)\n+ LoadDecreaseCost[n,t] * sum(G_DO[(n,t),h] for (n,t) in Nodes_Dispatch, h in Hours)\n...","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"that serve as soft-penalty proxies for the relative flexibility of different dispatchable generation technologies.","category":"page"},{"location":"tutorials/optmodel/#Capacity-investment-costs","page":"Model formulation","title":"Capacity investment costs","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For each modelling year, the fixed cost (annual) and the investment cost (amortised relative to the lifetime of the technology) are combined to form Z^textcap, where","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Z^textcap = Z^textfix + Z^textinv","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Here","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"beginalign*\nZ^textinv = \n     sum_n in textNodes sum_t in textTechs ic_(nt) N^textTECH_(nt) \n  + sum_n in textNodes sum_sto in textTechs ic^P_(nsto) N^textP_(nsto) + ic^E_(nsto) N^textE_(nsto) \n  + sum_n in textNodes sum_s in textSynCons ic^SYNC_(ns) N^textSYNC_(ns) \n  + sum_n in textNodes left sum_p in textP2G ic^P2G_(np) N^textP2G_(np) +  sum_g in textG2P ic^G2P_(ng) N^textG2P_(ng)\n  +  sum_gs in textGasSto ic^GS_(ngs) N^textGS_(ngs)  right \n  + sum_(n_Fn_T) in textArcs ic^IC_EXP_(n_Fn_T) N^textIC_EXP_(n_Fn_T)\nendalign*","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where the parameters ic refer to the present year investment costs. The objective term Z^textfix is analogously defined after replacing investment costs with fixed costs.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Continuing from above, the following terms are appear in the objective function as","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"+ sum(InvestmentCost[n,t] * N_TECH[(n,t)] for (n,t) in Nodes_Techs_New)\n\n+ sum(InvestmentCostPower[n,sto] * N_STO_P[(n,sto)] for (n,sto) in Nodes_Storages_New)\n+ sum(InvestmentCostEnergy[n,sto] * N_STO_E[(n,sto)] for (n,sto) in Nodes_Storages_New)\n\n+ sum(InvestmentCostSynCon[n,syn] * N_SYNC[(n,syn)] for (n,syn) in Nodes_SynCons)\n\n+ sum(InvestmentCost[n,p2g] * N_P2G[(n,p2g)] for (n,p2g) in Nodes_P2G)\n+ sum(InvestmentCost[n,g2p] * N_G2P[(n,g2p)] for (n,g2p) in Nodes_G2P)\n+ sum(InvestmentCost[n,gs] * N_GS[(n,gs)] for (n,gs) in Nodes_GasStorages)\n\n+ sum(ArcWeight[from,to]*InvestmentCostTransExp[from,to] * N_IC_EXP[(from,to)] for (from,to) in Arcs)\n\n+ sum(FixedCost[n,t] * N_TECH[(n,t)] for (n,t) in Nodes_Techs)\n+ sum(FixedCost[n,sto] * N_STO_P[(n,sto)] for (n,sto) in Nodes_Storages)\n\n+ sum(FixedCost[n,p2g] * N_P2G[(n,p2g)] for (n,p2g) in Nodes_P2G)\n+ sum(FixedCost[n,g2p] * N_G2P[(n,g2p)] for (n,g2p) in Nodes_G2P)\n+ sum(FixedCost[n,gs] * N_GS[(n,gs)] for (n,gs) in Nodes_GasStorages)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Note that while this formulation does not explicitly display discounting factors, these are applied in a separate pre-processing step.","category":"page"},{"location":"tutorials/optmodel/#Constraints","page":"Model formulation","title":"Constraints","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The model constraints are given here in both mathematical form and code implementation form.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"For compactness we abbreviate Nodes to N, Techs to T, Storages to S, and Arcs to A. ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"In the code formulation, constants of the form CapAdd[:CapacitySymbol][i,j,...] denote capacity quantities from the optimal capacity values from the model's solution in the previous time-step. Their use is to distinguish new capacity decision variables from prior capacity expansion data. Note that in the mathematical formulation there is no separate term corresponding to CapAdd. Instead, the capacity variables (e.g. N^textTECH) should be read as being inclusive of prior capacity expansion values, unless otherwise stated.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"The parameter tau, or time_ratio, is used to link energy variables and quantities (in MWh) to capacity (in MW). The constant relates generation levels during one time-step to energy on an hourly basis (MWh per hour). For example, a half-hourly time-step resolution means time_ratio = 1/2 while an hour time-step resolution has time_ratio = 1.","category":"page"},{"location":"tutorials/optmodel/#Energy-balance-and-load","page":"Model formulation","title":"Energy balance and load","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Definition of REZone generation book-keeping variables: for each z in REZones,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"G^textREZ_zh = \n    sum_t  (zt) in N times T G_(zt)h\n    + sum_sto  (zsto) in N times S (STO^textIN_(zsto)h - STO^textOUT_(zsto)h) ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, REZoneGen[rez=REZones,h=Hours],\n    G_REZ[rez,h] ==\n        sum(G[(z,t),h] for (z,t) in Nodes_Techs if z == rez)\n        +  sum(STO_OUT[(q,sto),h] - STO_IN[(q,sto),h] for (q,sto) in Nodes_Storages if q == rez)\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Definition of TxZone generation book-keeping variables: for each z in TxZones and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"G^textTxZ_(zt)h = \n    sum_t  (zt) in N times T G_(nt)h\n    + sum_sto  (zsto) in N times S (STO^textIN_(zsto)h - STO^textOUT_(zsto)h) \n    + sum_(rezt) in N times T    rez  uparrow z  G^textREZ_rezh - sum_(n_Fn_T) in A    n_F = z  F_(n_Fn_T)h ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where rez  uparrow z  means the renewable enegy zone rez is connected to the transmission zone z. ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, TxZoneGen[zone=TxZones,h=Hours],\n    G_TxZ[zone,h] ==\n        sum(G[(z,t),h] for (z,t) in Nodes_Techs if z == zone)\n        +  sum(STO_OUT[(z,sto),h] - STO_IN[(z,sto),h] for (z,sto) in Nodes_Storages if z == zone)\n        +  sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)\n        -  sum(FLOW[(from,to),h] for (from,to) in Arcs if from == zone)\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Energy balance at each demand node: supply equals or exceeds demand: for each n in DemandZones and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"G^textTxZ_(nt)h +  sum_g in textG2P  H2^textG2P_(ng)h\ngeq \nalpha^textTx  left widehatD_nh +  sum_p in textP2G  H2^textP2G_(np)h right","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where widehatD is the array of hourly demands at nodes, and alpha^textTx is a constant factor accounting for transmission line losses.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, EnergyBalance[n=DemandZones,h=Hours],\n    sum(G_TxZ[zone,h] for (zone, d) in Nodes_Demand if d == n)\n    + sum(H2_G2P[(zone,g2p),h] for (zone,g2p) in Nodes_G2P if zone == n)\n    >=\n    loss_factor_tx*(\n        Load[n,h]\n        + sum(H2_P2G[(zone,p2g),h] for (zone,p2g) in Nodes_P2G if zone == n))\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Energy flow reflexive constraint: for each (n_Fn_T) in Arcs and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"    F_(n_Fn_T)h = - F_(n_Tn_F)h","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, FlowEnergyReflex[(from,to)=Arcs,h=Hours; from in Arcs_From],\n    FLOW[(from,to),h] + FLOW[(to,from),h] == 0\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Energy flow bounds: for each (n_Fn_T) in Arcs and h in Hours, ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"    F_(n_Fn_T)h leq tau left( widehatC^textTx_(n_Fn_T) + N^textIC_EXP_(n_Fn_T) right)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where widehatC^textTx denotes existing capacity in transmission.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, FlowEnergyUpperBound[(from,to)=Arcs,h=Hours],\n    FLOW[(from,to),h] <= time_ratio * ( TransferCapacity[(from,to)] + N_IC_EXP[(from,to)] + CapAdd[:N_IC_EXP][(from,to)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Energy flow expansion symmetry: for each (n_Fn_T) in Arcs,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"N^textIC_EXP_(n_Fn_T) = N^textIC_EXP_(n_Tn_F)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, FlowEnergySymmetry[(from,to)=Arcs; from in Arcs_From],\n    N_IC_EXP[(from,to)] == N_IC_EXP[(to,from)]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Generation level start: for each (nt) in Nodes_Dispatch,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"    G_(nt)1 = G^uparrow_(nt)1","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, GenLevelStart[(n,t)=Nodes_Dispatch],\n            G[(n,t),Hours[1]] == G_UP[(n,t),Hours[1]]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Generation level dynamics: for each (nt) in Nodes_Dispatch, and for h in Hours, h neq 1,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"    G_(nt)h = G_(nt)h-1 + G^uparrow_(nt)h - G^downarrow_(nt)h","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, GenLevelUpdate[(n,t)=Nodes_Dispatch,h=Hours2],\n    G[(n,t),h] == G[(n,t),h-1] + G_UP[(n,t),h] - G_DO[(n,t),h]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Variable upper bound on dispatchable generation by capacity: for each (nt) in Nodes_Dispatch, and for h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"    G_(nt)h leq tau cdot widehatC^textDerate_(nt)h N^textTECH_(nt)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where widehatC^textDerate denotes capacity derating depending on generation technology type and hour-dependent characteristics (such as seasonal temperature factors).","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxGenerationDisp[(n,t)=Nodes_Dispatch,h=Hours],\n    G[(n,t),h] <= CapacityDerating[n,t,h] * time_ratio * (N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Variable upper bound on non-dispatchable generation by capacity: for each (nt) in Nodes_Avail_Techs, and for h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"G_(nt)h leq tau cdot widehatC^textAvail_(nt)h N^textTECH_(nt)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where widehatC^textAvail denotes the availability of a variable renewable source (a value between 0 and 1 inclusive).","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxGenerationNonDisp[(n,t)=Nodes_Avail_Techs,h=Hours],\n    G[(n,t),h] <= Availability[n,t,h] * time_ratio * (N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Maximum capacity allowed: for each (nt) in Nodes_Techs,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"    N^textTECH_(nt) leq widehatN^textTECH_(nt)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxCapacityBound[(n,t)=Nodes_Techs; !(MaxCapacity[n,t] |> ismissing)],\n    N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)] <= MaxCapacity[n,t]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Maximum generated energy allowed: for each (nt) in Nodes_Techs,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"    sum_h in Hours G_(nt)h leq widehatE_(nt)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxEnergyGenerated[(n,t)=Nodes_Techs; !(MaxEnergy[n,t] |> ismissing)],\n    sum(G[(n,t),h] for h in Hours) <= MaxEnergy[n,t]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Renewable energy zone build limits: for each z in REZones and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"sum_h in Hours G_(zt)h leq tau left( widehatC^textRX_z + N^textRX_z right)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where the widehatC^textRX term denotes the available hosting capacity in a zone before further expansion capacity N^textRX is required.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, REZBuildLimits[rez=REZones,h=Hours],\n    sum(G[(z,t),h] for (z,t) in Nodes_Avail_Techs if z == rez)\n        <= time_ratio*(TotalBuildCap[rez] +  N_REZ_EXP[rez] + CapAdd[:N_REZ_EXP][rez])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Renewable energy zone expansion limits: for each z in REZones,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"N^textRX_z leq widehatN^textRX_z ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, REZExpansionBound[rez=REZones],\n    N_REZ_EXP[rez] + trunc(CapAdd[:N_REZ_EXP][rez]) <= ExpansionLimit_REZ[rez]\n);","category":"page"},{"location":"tutorials/optmodel/#Operational-conditions-and-constraints","page":"Model formulation","title":"Operational conditions and constraints","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Maximum ramp up rates: for each (nt) in Nodes_RampingTechs, and for h in Hours, h neq 1,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"    G^uparrow_(nt)h  leq tau  widehatC^uparrow_t","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where widehatC^uparrow denotes technology-specific ramp-up rates.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, RampingUpLimits[(n,t)=Nodes_RampingTechs, h=Hours2],\n    G_UP[(n,t),h] <= time_ratio * MaxRampUpPerHour[t]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Maximum ramp down rates: for each (nt) in Nodes_RampingTechs, and for h in Hours, h neq 1,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"    G^downarrow_(nt)h  leq tau  widehatC^downarrow_t","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where widehatC^downarrow denotes technology-specific ramp-up rates.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, RampingDownLimits[(n,t)=Nodes_RampingTechs, h=Hours2],\n    G_DO[(n,t),h] <= time_ratio * MaxRampDownPerHour[t]\n)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Operating reserve margin: for particular regions dr in DemandRegions and for all h in Hours, the margin between available power generation and total capacity must remain greater than or equal to the applicable operating reserve.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, OperatingReserve[dr=DemandRegions, h=Hours],\n    sum( CapacityDerating[n,t,h] * time_ratio * (N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)]) - G[(n,t),h]\n        for (n,t) in Nodes_Dispatch if node2DemReg[n] == dr)\n    + sum( PeakContribution[n,t] * time_ratio * (N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)])\n        for (n,t) in Nodes_Avail_Techs if node2DemReg[n] == dr)  # or replace `Nodes_Avail_Techs` with `setdiff(Nodes_Avail_Techs,Nodes_Dispatch)`\n    + sum( sqrt(Efficiency[n,sto])*STO_L[(n,sto), h]\n        for (n,sto) in Nodes_Storages if node2DemReg[n] == dr)\n    >= time_ratio * OperatingReserve[dr]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Minimum stable generation levels: certain generation technologies must remain above a prescribed level as part of maintaining a stable operating state; for each (nt) in Nodes_Dispatch, and for h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"    G_(nt)h geq tau cdot widehatSG_(nt) cdot widehatC^textDerate_(nt)h N^textTECH_(nt)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where widehatSG is a fraction between 0 and 1 denoting the proportion of available capacity that should be operational and supplying power.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MinStableGeneration[(n,t)=keys(MinStableGen), h=Hours; !(MinStableGen[n,t] |> ismissing)],\n    G[(n,t),h] >= MinStableGen[n,t] * CapacityDerating[n,t,h] * time_ratio * (N_TECH[(n,t)] + CapAdd[:N_TECH][(n,t)])\n);","category":"page"},{"location":"tutorials/optmodel/#Requirements-for-renewable-generation","page":"Model formulation","title":"Requirements for renewable generation","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Minimum yearly renewables requirement: for each demand region n in DemandRegions, we require that a specified proportion of power is generated from variable renewable sources. ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MinRES[n=DemandRegions],\n    sum(\n        sum(G[(z,t),h] for (z,t) in Nodes_Renew if z == zone)  # Any renewable TxZone-level tech.\n        + sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)\n    for (zone, d) in Nodes_Demand if node2DemReg[d] == n\n    for h in Hours\n    )\n    >=\n    (min_res_dict[n]/100)*(\n        sum(\n            sum(G[(z,t),h] for (z,t) in Nodes_Techs if z == zone)\n            + sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)\n        for (zone, d) in Nodes_Demand if node2DemReg[d] == n\n        for h in Hours\n        )\n    )\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Minimum yearly renewables requirement for whole-of-system: across the whole-of-system demand, we require that a specified proportion of power is generated from variable renewable sources. ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MinRESsystem,\n    sum(\n        sum(\n            sum(G[(z,t),h] for (z,t) in Nodes_Renew if z == zone)  # Any renewable TxZone-level tech.\n            + sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)\n            for (zone, d) in Nodes_Demand if node2DemReg[d] == n\n        for h in Hours)\n    for n in DemandRegions)\n        >=\n        (MinimumRenewShare/100)*sum(\n            sum(\n                sum(G[(z,t),h] for (z,t) in Nodes_Techs if z == zone)\n                + sum(G_REZ[rez,h] for (rez, z) in Nodes_Promotes if z == zone)\n                for (zone, d) in Nodes_Demand if node2DemReg[d] == n\n            for h in Hours)\n        for n in DemandRegions)\n);","category":"page"},{"location":"tutorials/optmodel/#Storage-technologies","page":"Model formulation","title":"Storage technologies","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage level dynamics: initial condition: for each (nsto) in Nodes_Storages,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"STO^textL_(nsto)1 = sigma_0  widehatSoC^textmax_sto  N^textE_(nsto) + rho_(nsto)^12 STO^textIN_(zsto)1 - rho_(nsto)^-12 STO^textOUT_(zsto)1","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"sigma_0 is the starting state-of-charge proportion (between 0 and 1, default value 0.5)\nwidehatSoC^textmax is the maximum state-of-charge proportion (between 0 and 1) relative to the nominal energy storage capacity, and\nrho denotes storage round-trip efficiency.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, StorageLevelStart[(n,sto)=Nodes_Storages],\n    STO_L[(n,sto),Hours[1]]\n        ==\n    StartLevel[n,sto] * MaximumSoC[sto] * (N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)])\n    +   sqrt(Efficiency[n,sto])*STO_IN[(n,sto), Hours[1]]\n    - 1/sqrt(Efficiency[n,sto])*STO_OUT[(n,sto), Hours[1]]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage end level equal to initial level: for each (nsto) in Nodes_Storages,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"STO^textL_(nsto)end = sigma_0  widehatSoC^textmax_sto  N^textE_(nsto)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, StorageLevelEnd[(n,sto)=Nodes_Storages],\n    STO_L[(n,sto),Hours[end]]\n        ==\n    StartLevel[n,sto] * MaximumSoC[sto] * (N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage level dynamics: for each (nsto) in Nodes_Storages and h in Hours, h neq 1,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"STO^textL_(nsto)h = STO^textL_(nsto)h-1 + rho_(nsto)^12 STO^textIN_(nsto)h - rho_(nsto)^-12 STO^textOUT_(nsto)h","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, StorageBalance[(n,sto)=Nodes_Storages,h=Hours2],\n    STO_L[(n,sto), h]\n    ==\n    STO_L[(n,sto), h-1]\n    +   sqrt(Efficiency[n,sto])*STO_IN[(n,sto), h]\n    - (1/sqrt(Efficiency[n,sto]))*STO_OUT[(n,sto), h]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage energy capacity: for each (nsto) in Nodes_Storages and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"STO^textL_(nsto)h leq widehatSoC^textmax_sto  N^textE_(nsto)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxLevelStorage[(n,sto)=Nodes_Storages,h=Hours],\n    STO_L[(n,sto),h] <= MaximumSoC[sto] * (N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage maximum inflow: for each (nsto) in Nodes_Storages and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"STO^textIN_(nsto)h leq tau  N^textP_(nsto)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxWithdrawStorage[(n,sto)=Nodes_Storages,h=Hours],\n    STO_IN[(n,sto),h] <= time_ratio * (N_STO_P[(n,sto)] + CapAdd[:N_STO_P][(n,sto)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage generation outflow by capacity: for each (nsto) in Nodes_Storages and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"STO^textOUT_(nsto)h leq tau  N^textP_(nsto)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxGenerationStorage[(n,sto)=Nodes_Storages,h=Hours],\n    STO_OUT[(n,sto),h] <= time_ratio * (N_STO_P[(n,sto)] + CapAdd[:N_STO_P][(n,sto)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage: maximum energy allowed: impose an energy capacity upper bound for each (nsto) in Nodes_Storages;","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"if !(isDictAllMissing(dtr.parameters[:MaxEnergy]))\n    @constraint(m, MaxEnergyStorage[(n,sto)=Nodes_Storages; !(MaxEnergy[n,sto] |> ismissing)],\n        N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)] <= MaxEnergy[n,sto]\n    );\nend","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage: maximum power allowed: impose a power capacity upper bound for each (nsto) in Nodes_Storages;","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxPowerStorage[(n,sto)=Nodes_Storages; !(MaxCapacity[n,sto] |> ismissing)],\n    N_STO_P[(n,sto)] + CapAdd[:N_STO_P][(n,sto)] <= MaxCapacity[n,sto]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage: maximum energy-to-power ratio (duration): for each (nsto) in Nodes_Storages,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"(1 - epsilon_T) widehatT_(nsto) N^textP_(nsto) leq N^textE_(nsto) leq (1 + epsilon_T)  widehatT_(nsto) N^textP_(nsto)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where widehatT denotes a specified storage duration, and epsilon_T is a constraint tolerance.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"tol_EtoP = 0.01 ## Constraint tolerance for matching energy to power ratio\n\n@constraint(m, EnergyToPowerRatioUp[(n,sto)=Nodes_Storages; !(MaxEtoP_ratio[n,sto] |> ismissing)],\n    N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)] <= (1 + tol_EtoP) * MaxEtoP_ratio[n,sto] * (N_STO_P[(n,sto)] + CapAdd[:N_STO_P][(n,sto)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, EnergyToPowerRatioLo[(n,sto)=Nodes_Storages; !(MaxEtoP_ratio[n,sto] |> ismissing)],\n    N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)] >= (1 - tol_EtoP) * MaxEtoP_ratio[n,sto] * (N_STO_P[(n,sto)] + CapAdd[:N_STO_P][(n,sto)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage: maximum outflow - no more than level of last period: for each (nsto) in Nodes_Storages and h in Hours, h neq 1,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"rho_(nsto)^-12 STO^textOUT_(nsto)h leq STO^textL_(nsto)h-1","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxOutflowStorage[(n,sto)=Nodes_Storages,h=Hours2],\n    (1/sqrt(Efficiency[n,sto]))*STO_OUT[(n,sto),h] <= STO_L[(n,sto),h-1]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage: maximum inflow - no more than energy capacity minus level of last period: for each (nsto) in Nodes_Storages and h in Hours, h neq 1,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"rho_(nsto)^12 STO^textIN_(nsto)h leq widehatSoC^textmax_sto N^textE_(nsto) - STO^textL_(nsto)h-1","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxInflowStorage[(n,sto)=Nodes_Storages,h=Hours2],\n    sqrt(Efficiency[n,sto])*STO_IN[(n,sto),h] <= MaximumSoC[sto] * (N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)]) - STO_L[(n,sto),h-1]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Storage: maximum annual cycles - equivalent number of full discharges less than annual cycle number: for each (nsto) in Nodes_Storages,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"sum_h in textHours STO^textOUT_(nsto)h leq nu_sto widehatSoC^textmax_sto  N^textE_(nsto)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where the total equivalent number of times the storage technology undergoes a full discharge is specified by nu_sto.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(m, MaxYearlyDischargeCycles[(n,sto)=Nodes_Storages; haskey(AnnualCycleNumber,sto)],\n    sum(STO_OUT[(n,sto),h] for h in Hours) <= AnnualCycleNumber[sto] * MaximumSoC[sto] * (N_STO_E[(n,sto)] + CapAdd[:N_STO_E][(n,sto)])\n);","category":"page"},{"location":"tutorials/optmodel/#Hydrogen-technologies","page":"Model formulation","title":"Hydrogen technologies","text":"","category":"section"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: minimum yearly lower bound on power-to-gas: for each (np) in Nodes_P2G, ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"sum_h in textHours H2^textP2G_(np)h geq widehatD^textH2_(np2g)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where widehatD^textH2 denotes annual hydrogen production demand at particular spatial locations for a given electrolyser tecnhnology.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, MinYearlyP2G[(n,p2g)=Nodes_P2G],\n    sum(H2_P2G[(n,p2g),h] for h in Hours) >= H2Demand[n,p2g]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: constant hourly lower bound on power-to-gas technology: for each (np) in Nodes_P2G and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"H2^textP2G_(np)h geq widehatCF^textLB_n fracwidehatD^textH2_(np2g) textHours   ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where  textHours  is the number of time-steps (typically 8760 hours per year) and widehatCF^textLB is capacity factor lower bound data for typical plant operation.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, MinHourlyP2G_AE[(n,p2g)=Nodes_P2G_AE, h=Hours],\n    H2_P2G[(n,p2g),h] >= AE_Capacity_Factor_LB*(H2Demand[n,p2g]/periods)\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, MinHourlyP2G_PEM[(n,p2g)=Nodes_P2G_PEM, h=Hours],\n    H2_P2G[(n,p2g),h] >= PEM_Capacity_Factor_LB*(H2Demand[n,p2g]/periods)\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: variable upper bound on power-to-gas: for each (np) in Nodes_P2G and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"H2^textP2G_(np)h leq widehatCF^textUB_n N^textP2G_(np)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where widehatCF^textUB is capacity factor upper bound data for typical plant operation.","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, MaxP2G[(n,p2g)=Nodes_P2G,h=Hours],\n    H2_P2G[(n,p2g),h] <= time_ratio * H2_P2G_Capacity_Factor_UB * (N_P2G[(n,p2g)] + CapAdd[:N_P2G][(n,p2g)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: variable upper bound on gas-to-power: for each (ng) in Nodes_G2P and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"H2^textG2P_(ng)h leq N^textG2P_(ng)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, MaxG2P[(n,g2p)=Nodes_G2P,h=Hours],\n    H2_G2P[(n,g2p),h] <= time_ratio * (N_G2P[(n,g2p)] + CapAdd[:N_G2P][(n,g2p)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: capacity factor upper bound on gas-to-power: for each (ng) in Nodes_G2P and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"sum_h in textHours H2^textG2P_(ng)h leq  widehatCF^textUB_n  N^textG2P_(ng)  textHours  ","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, MaxCapFactorH2_G2P[(n,g2p)=Nodes_G2P],\n    sum(H2_G2P[(n,g2p),h] for h in Hours) <= RecipH2_CF_UB*length(Hours)*(N_G2P[(n,g2p)] + CapAdd[:N_G2P][(n,g2p)])\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: variable upper bound on gas storage: for each (ngs) in Nodes_GasStorages and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"  H2^textGS_L_(ngs)h leq N^textGS_(ngs)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, MaxLevelGasStorage[(n,gs)=Nodes_GasStorages,h=Hours],\n    H2_GS_L[(n,gs),h] <= N_GS[(n,gs)] + CapAdd[:N_GS][(n,p2g)]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: conversion into gas storage: for each (ngs) in Nodes_GasStorages and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"H2^textGS_IN_(ngs)h = sum_(ng) in N times textP2G fracH2^textP2G_(np)hgamma_(np)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"where gamma_(ng) is a conversion factor between units of stored hydrogen and electricity consumption (typically H2Conversion = gamma = 15.2 MWh / t-H2 ).","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, GasStorageIn[(n,gs)=Nodes_GasStorages,h=Hours],\n    H2_GS_IN[(n,gs),h] == sum(H2_P2G[(n,p2g),h]/H2Conversion[n,p2g] for (n,p2g) in Nodes_P2G)\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: conversion out of gas storage: for each (ngs) in Nodes_GasStorages and h in Hours,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"H2^textGS_OUT_(ngs)h = sum_(ng) in N times textG2P fracH2^textG2P_(ng)hgamma_(ng)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, GasStorageOut[(n,gs)=Nodes_GasStorages,h=Hours],\n    H2_GS_OUT[(n,gs),h] == sum(H2_G2P[(n,g2p),h]/H2Conversion[n,g2p] for (n,g2p) in Nodes_G2P)\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: gas storage mass balance: for each (ngs) in Nodes_GasStorages and h in Hours, h neq 1,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":" H2^textGS_L_(ngs)h =  H2^textGS_L_(ngs)h-1 + H2^textGS_IN_(ngs)h - H2^textGS_OUT_(ngs)h","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, GasStorageBalance[(n,gs)=Nodes_GasStorages,h=Hours2],\n    H2_GS_L[(n,gs), h] == H2_GS_L[(n,gs), h-1] + H2_GS_IN[(n,gs), h] - H2_GS_OUT[(n,gs), h]\n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: gas storage balance at first time-steps: for each (ngs) in Nodes_GasStorages,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"H2^textGS_L_(ngs)1 = sigma_0  N^textGS_(ngs) + H2^textGS_IN_(ngs)1 - H2^textGS_OUT_(ngs)1","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, GasStorageBalanceFirstHours[(n,gs)=Nodes_GasStorages],\n    H2_GS_L[(n,gs), Hours[1]] == StartLevel[n,gs] * ( N_GS[(n,gs)] + CapAdd[:N_GS][(n,gs)]) + H2_GS_IN[(n,gs),Hours[1]] - H2_GS_OUT[(n,gs),Hours[1]]  # \n);","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"Hydrogen: gas storage end level equal to initial level: for each (ngs) in Nodes_GasStorages,","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"H2^textGS_L_(ngs)1 = sigma_0  N^textGS_(ngs)","category":"page"},{"location":"tutorials/optmodel/","page":"Model formulation","title":"Model formulation","text":"@constraint(dtr.model, GasStorageLevelEnd[(n,gs)=Nodes_GasStorages],\n    H2_GS_L[(n,gs), Hours[end]] == StartLevel[n,gs] * ( N_GS[(n,gs)] + CapAdd[:N_GS][(n,gs)])\n);","category":"page"},{"location":"api/internal/#Internal-API","page":"Internal API Reference","title":"Internal API","text":"","category":"section"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [Dieter]\nPublic = false","category":"page"},{"location":"api/internal/#Dieter.calc_inv_storages!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.calc_inv_storages!","text":"Calculate the amortised investment cost of technologies from capital costs.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.calc_inv_tech!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.calc_inv_tech!","text":"Calculate the amortised investment cost of technologies from capital costs.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.calc_mc!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.calc_mc!","text":"Calculated marginal costs for plants including variable costs\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.convert_jump_container_to_df-Tuple{JuMP.Containers.DenseAxisArray}","page":"Internal API Reference","title":"Dieter.convert_jump_container_to_df","text":"Returns a DataFrame with the values of the variables from the JuMP container var. The column names of the DataFrame can be specified for the indexing columns in dim_names, and the name of the data value column by a Symbol value_col e.g. :Value\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.initialise_data_dir_structure-Tuple{Any}","page":"Internal API Reference","title":"Dieter.initialise_data_dir_structure","text":"Initialise a basic file structure for accessing the model data. The default directory structure is: <datapath>/ ├── base │   ├── availability.csv │   ├── load.csv │   ├── storages.csv │   └── technologies.csv ├── ev │   ├── ev.csv │   ├── evdemand.csv │   └── evpower.csv ├── h2 │   └── h2technologies.csv └── heat     ├── buildings.csv     ├── dhwdemand.csv     ├── heat.csv     ├── heatdemand.csv     ├── heattechnologies.csv     └── temperature.csv\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.initialise_set_relation_data!-Tuple{Any}","page":"Internal API Reference","title":"Dieter.initialise_set_relation_data!","text":"Create the mathematical set relations for doing set-correspondences in models.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.isDictAllMissing-Tuple{Dict}","page":"Internal API Reference","title":"Dieter.isDictAllMissing","text":"Check if a Dictionary has all missing values; if so, return true\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.map_dfheader_to_col-Tuple{DataFrames.DataFrame}","page":"Internal API Reference","title":"Dieter.map_dfheader_to_col","text":"Create a Dict from a DataFrame with the DataFrame column-names as keys and columns as values.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.map_idcol-Tuple{DataFrames.DataFrame, Int64}","page":"Internal API Reference","title":"Dieter.map_idcol","text":"Return a dictionary of Dicts from a DataFrame with column-names as keys, and each Dict has a key-value pair of idcols => data-value. Column symbols listed in `skipcols` are skipped.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14, z=2:5)\n4×3 DataFrame\n│ Row │ x     │ y     │ z     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 11    │ 2     │\n│ 2   │ 2     │ 12    │ 3     │\n│ 3   │ 3     │ 13    │ 4     │\n│ 4   │ 4     │ 14    │ 5     │\n\njulia> map_idcol(df, 1, skip_cols=[:z])\nDict{Symbol,Dict} with 1 entry:\n  :y => Dict(4=>14,2=>12,3=>13,1=>11)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.parse_base_technologies!-Tuple{DieterModel}","page":"Internal API Reference","title":"Dieter.parse_base_technologies!","text":"Expected Dieter model parameters read into dtr.parameters: ExistingCapacity, FuelCost, FixedCost, VariableCost, OvernightCost, CurtailmentCost, LoadIncreaseCost, LoadDecreaseCost, Lifetime, MaxCapacity, MaxEnergy, TechTypeCategory, Renewable, Dispatchable, FuelSource, Efficiency, CarbonContent, CO2_price\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.parse_file-Tuple{String}","page":"Internal API Reference","title":"Dieter.parse_file","text":"Parse a given data file and return the desired data in a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.split_df_tuple-Tuple{DataFrames.DataFrame, Symbol, Vector{Symbol}}","page":"Internal API Reference","title":"Dieter.split_df_tuple","text":"split_df_tuple is a function that transforms a DataFrame with a Tuple{N,M...} type column. It outputs an augmented DataFrame with the tuples split into two columns of type N, M... resp.\n\nThe function splits the column InputCol of type Tuple into individual columns named with OutputCols vector of Symbols. Note that the Symbols in OutputCols need to be of the name length and order to correspond to the splitting Tuples.\n\nArguments\n\ndf : a DataFrame\nInputCol : a Symbol for a column of type Tuple{Types...}\nOutputCols: a Vector of Symbols for new column names,\n\nReturns\n\n::DataFrame\n\nExamples\n\n```  julia> using DataFramesMeta, DataFrames\n\njulia> df = DataFrame(A_N = [(\"a\",1),(\"b\",2)], V = [8,9]);\n\njulia> splitdftuple(df, :AN, [:A, :N]) 2×4 DataFrame │ Row │ AN      │ V     │ A      │ N     │ │     │ Tuple…   │ Int64 │ String │ Int64 │ ├─────┼──────────┼───────┼────────┼───────┤ │ 1   │ (\"a\", 1) │ 8     │ a      │ 1     │ │ 2   │ (\"b\", 2) │ 9     │ b      │ 2     │  ```\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.table2df-Tuple{Any}","page":"Internal API Reference","title":"Dieter.table2df","text":"Function to convert an Array{Any,2} with a header row of column name strings to a DataFrame\n\nThanks: https://stackoverflow.com/questions/25894634/dataframe-from-array-with-header\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.tableToDict-Tuple{Matrix}","page":"Internal API Reference","title":"Dieter.tableToDict","text":"tableToDict(tab::Array{Any,2}; keycols::Array{Int64,1}=[1])\n\nCreate a dictionary from an array in table form, where the table tab has:\n\nkey-index or indices given in the keycol array (integer column position), and\nthe column names for data appear in the first row.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.update_dict!-Tuple{Dict{Symbol, Dict}, Symbol, Dict}","page":"Internal API Reference","title":"Dieter.update_dict!","text":"Update a data Dict, merging the data if present, adding data if not present\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Dieter.@def-Tuple{Any, Any}","page":"Internal API Reference","title":"Dieter.@def","text":"The def macro is used to build other macros that can insert the same block of Julia code into different parts of a program. This is macro is used to generate a standard set of fields inside a model type hierarchy. (Thanks: InfrastructureModels.jl; see http://www.stochasticlifestyle.com/type-dispatch-design-post-object-oriented-programming-julia/)\n\n\n\n\n\n","category":"macro"},{"location":"api/internal/#Dieter.@dm_fields-Tuple{}","page":"Internal API Reference","title":"Dieter.@dm_fields","text":"A macro for adding the basic fields to an AbstractDieterModel type definition.\n\n\n\n\n\n","category":"macro"},{"location":"#Dieter.jl","page":"Welcome Page","title":"Dieter.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = Dieter","category":"page"},{"location":"#Table-of-Contents","page":"Welcome Page","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Pages = [\"index.md\", \"tutorials/optmodel.md\"]\nDepth = 3","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"DIETER is the Dispatch and Investment Evaluation Tool with Endogenous Renewables, an open energy system model developed by the German Institute for Economic Research (DIW Berlin). The model is structured as a cost-minimising linear program that when solved to optimality will produce an hourly operation profile of an interconnected transmission system over a single year, including aspects such as","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"generator power output,\nstorage technology charge and discharge,\ntransmission flows,\nvariable renewable energy utilisation, and\nhydrogen electrolyser operation.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The model also decides on cost-optimal capacity expansion of relevant model technologies relative to the year under consideration.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"This code repository holds a derivative version of DIETER written using the Julia language and the JuMP algebraic modelling language (a Julia package). While the original version of DIETER is implemented in GAMS, Julia/JuMP enables a free and open-source implementation. Linear programming (LP) solvers are required to compute optimal solutions, and both free/open-source and commercial solver can be freely interchanged using interfaces via JuMP (commercial solvers such as the Gurobi LP solver may required for obtaining reasonable run times when solving large-scale problems).","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The Dieter.jl Julia/JuMP package has been developed at CSIRO within the Energy Systems research program. Thanks to Mario Kendziorski for an earlier version, as well as Wolf-Peter Schill.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"In keeping with the original version, Dieter.jl is open source and may be freely used and modified by anyone. Contributions are welcome.","category":"page"},{"location":"#Model-code","page":"Welcome Page","title":"Model code","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For a quick overview, the model code can be directly viewed in the model.jl file.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Note that the model is (currently) lacking some features which exist in the GAMS model such as the representation of reserves and prosumage.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"General utility functions for handling DataFrames, Dicts and translations from JuMP data structures, useful independently of Dieter.jl, are to be found in the util.jl file.","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"This package is not registered on the Julia package system. To install this as a Julia module in a Julia REPL session, you can run the following package installation commands to install directly from the model code repository:","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"import Pkg\nPkg.add(Pkg.PackageSpec(url=\"https://github.com/csiro-energy-systems/Dieter.jl.git\"; rev=\"main\"))","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The argument rev=\"main\" selects the git branch to use; change this to use your own alternative branch as required.","category":"page"},{"location":"#Example-of-a-run-script","page":"Welcome Page","title":"Example of a run script","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"To run the model, one might use a script similar to the following, however this currently requires user customisation to work:","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"using Dieter\nusing JuMP\n\n# select your favourite solver\nusing HiGHS\nsolver = HiGHS.Optimizer\n# using Gurobi\n# solver = Gurobi.Optimizer\n# using CPLEX\n# solver = CPLEX.Optimizer\n\ncurrent_dir = @__DIR__\ndatapath = joinpath(current_dir,\"test\",\"testdata\")\n\n# set the Dieter parameters\ndtr = InitialiseDieterModel(DieterModel, Dict{String,Any}())\ndtr.settings[:datapath] = datapath\n\ninitialise_data_file_dict!(dtr)\ncheck_files_exist(dtr.data[\"files\"])\n\ndbfilepath = joinpath(datapath,\"DTR_regions_test_data/DTR.db\")\ndfDict = parse_data_to_model!(dtr; dataname=dbfilepath)\n\nbuild_model!(dtr)\n\nJuMP.set_optimizer(dtr.model, solver)\nsolve_model!(dtr)\n\ngenerate_results!(dtr)","category":"page"},{"location":"api/public/#Public-API-Reference","page":"Public API Reference","title":"Public API Reference","text":"","category":"section"},{"location":"api/public/#Modeling","page":"Public API Reference","title":"Modeling","text":"","category":"section"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [Dieter]\nPages   = [\"Dieter.jl\",\n           \"model.jl\",\n           \"struct.jl\",\n           \"util.jl\",\n           \"base.jl\"]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/public/#Dieter.build_model!-Tuple{DieterModel}","page":"Public API Reference","title":"Dieter.build_model!","text":"Build the JuMP model describing the optimization problem, specifying the solver to use. The Timestep parameter should be 1 for half-hourly steps, 2 for hourly steps, and 4 for 2-hourly steps. The data must match the time-steps of the Timestep parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.InitialiseDieterModel-Tuple{Type, Dict{String}}","page":"Public API Reference","title":"Dieter.InitialiseDieterModel","text":"Default constructor for a Dieter model, initialised with the Model DataType and a user-specified data Dict associated with the model in the constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.initialise_data_file_dict!-Tuple{Dieter.AbstractDieterModel, String}","page":"Public API Reference","title":"Dieter.initialise_data_file_dict!","text":"Initialise the strings giving the file-path references to the model data. The argument sfx is the file suffix of each model data file. Currently, sfx can be either \"csv\" or \"sql\"\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.check_files_exist-Tuple{Dict{String, String}}","page":"Public API Reference","title":"Dieter.check_files_exist","text":"Given a Dict of keys => filenames, check at files exist\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.create_relation-Tuple{DataFrames.DataFrame, Symbol, Symbol, Symbol}","page":"Public API Reference","title":"Dieter.create_relation","text":"Using a DataFrame, create_relation returns a function that can be used to determine a 2-valued relation, that is, a set-to-set correspondence. DataFrame column-names (Symbols) are given that define the set tuples, and a third Indicator column-name is used to indicate set membership. The return type is a function that can be used with two \"sets\" A and B in tuple2_filter(func,A,B) = filter(x->func(x[1],x[2]), [(a,b) for a in A for b in B])\n\n\n\n\n\n","category":"method"},{"location":"api/public/#Dieter.parse_data_to_model!-Tuple{Dieter.AbstractDieterModel}","page":"Public API Reference","title":"Dieter.parse_data_to_model!","text":"Build the data for the model, returning intermediate DataFrames containing parsed data. The function will not parse data where the corresponding model setting equals missing.\n\n\n\n\n\n","category":"method"}]
}
